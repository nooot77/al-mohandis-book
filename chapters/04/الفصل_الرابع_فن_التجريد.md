# الفصل الرابع: فن التجريد

## التجريد كفلسفة وقوة

---

## مقدمة: لماذا التجريد؟

> "التجريد هو فن إخفاء التعقيد وراء واجهة بسيطة، دون أن تفقد القدرة على التحكم فيه."

في عالم يتسم بالتعقيد المتزايد، يصبح التجريد (Abstraction) ليس مجرد أداة تقنية، بل **فلسفة وجودية** لإدارة المعرفة والقوة.

التجريد الجيد يمنحنا:
- **القدرة على التحكم**: نتحكم في الأنظمة المعقدة
- **القدرة على الفهم**: نفهم ما وراء السطح
- **القدرة على الابتكار**: نبني فوق ما سبق

### التجريد في الطبيعة

الطبيعة تُجريد ببراعة:
- **الخلايا** تخفي تعقيد الكيمياء الحيوية
- **الأعضاء** تخفي تعقيد الخلايا
- **الكائنات** تخفي تعقيد الأعضاء

كل مستوى يُقدم واجهة بسيطة للمستوى الأعلى، دون أن يفقد قدرته على العمل.

### التجريد في الفلسفة

**أرسطو:**
المُثُل (Forms) هي التجريدات المثالية وراء الأشياء المادية.

**أفلاطون:**
ما نراه هو ظلال التجريدات الحقيقية.

**الوجوديون:**
التجريد يمنح المعنى للوجود الفوضوي.

---

## 4.1 مفهوم التجريد العميق

### ما هو التجريد؟

**التعريف:**
التجريد هو عملية عزل الخصائص الجوهرية عن الخصائص العرضية.

**الأبعاد:**

#### البعد اللغوي
الكلمة "كرسي" تجريد لكل كائنات الكراسي المحددة.

#### البعد المنطقي
الفئة (Class) في البرمجة كائنية التوجه.

#### البعد الفلسفي
المفهوم (Concept) وراء الظواهر.

### أنواع التجريد

#### 1. التجريد بالإخفاء (Abstraction by Hiding)
**المبدأ:**
نخفي التفاصيل غير الضرورية.

**مثال:**
```
المستخدم يرى: زر "إرسال"
ما يحدث: Validation → Processing → Database → Notification → Logging
```

**الفلسفة:**
المستخدم لا يحتاج لمعرفة كيف يعمل، بل أنه يعمل.

#### 2. التجريد بالتعميم (Abstraction by Generalization)
**المبدأ:**
نستخرج الخصائص المشتركة.

**مثال:**
```
الكلب + القطة + الفيل = حيوان
```

**الفلسفة:**
المشترك أعمق وأبقى من المتفرد.

#### 3. التجريد بالتركيب (Abstraction by Composition)
**المبدأ:**
نبني تعقيداً من بساطة.

**مثال:**
```
الحرف → الكلمة → الجملة → الفقرة → الكتاب
```

**الفلسفة:**
البسيط المتكرر يبني المعقد.

### مستويات التجريد

```
المستوى 7: المفاهيم الفلسفية
          ↓
المستوى 6: المجالات (Domains)
          ↓
المستوى 5: الأنماط المعمارية
          ↓
المستوى 4: المكونات
          ↓
المستوى 3: الفئات والدوال
          ↓
المستوى 2: الخوارزميات
          ↓
المستوى 1: البتات والبوابات المنطقية
```

**القاعدة:**
كل مستوى يُجريد المستوى الذي تحته.

---

## 4.2 تاريخ التجريد في البرمجة

### المرحلة الأولى: الآلة (1950s)

**الواقع:**
المبرمجون يكتبون Assembly.
كل تعليمة تتوافق مع عملية hardware.

**التجريد:**
لا يوجد تقريباً.

**التحدي:**
صعوبة البرمجة، قلة النتاجية.

### المرحلة الثانية: اللغات عالية المستوى (1960s-1970s)

**الاختراق:**
FORTRAN, COBOL, C.

**التجريد:**
```
الكود: x = a + b
الآلة: LOAD a; ADD b; STORE x
```

**الفائدة:**
المبرمج يفكر في العمليات لا الذاكرة.

### المرحلة الثالثة: البرمجة الكائنية (1980s-1990s)

**الاختراق:**
Smalltalk, C++, Java.

**التجريد:**
الكائنات تحمل البيانات والسلوك.

**الفائدة:**
نمذجة العالم ككائنات متفاعلة.

### المرحلة الرابعة: المكونات والأنماط (2000s)

**الاختراق:**
Components, Design Patterns, Frameworks.

**التجريد:**
المكونات الجاهزة تُبنى فوقها.

**الفائدة:**
إعادة الاستخدام، سرعة التطوير.

### المرحلة الخامسة: الخدمات والسحابة (2010s-2020s)

**الاختراق:**
Microservices, Serverless, Cloud.

**التجريد:**
```
المبرمج يرى: Function
السحابة تعمل: VMs, Containers, Load Balancers, Networks, Storage
```

**الفائدة:**
التركيز على المنطق لا البنية التحتية.

### المرحلة السادسة: AI والتوليد (2020s-...)

**الاختراق:**
GPT, Copilot, Code Generation.

**التجريد:**
```
الوصف: "بناء نظام حجوزات"
الكود: تلقائياً
```

**التحدي الجديد:**
ماذا يجريد ماذا؟ ومن يتحكم في من؟

---

## 4.3 فلسفة التجريد

### البارادوكس المركزي

**التجريد يعطي ويأخذ:**

**يعطي:**
- البساطة
- إعادة الاستخدام
- الحماية من التغيير

**يأخذ:**
- التحكم المباشر
- الرؤية الكاملة
- المرونة الدقيقة

**الفلسفة:**
> "كل تجريد، بطريقة ما، خيانة." - Joel Spolsky

لكنها خيانة ضرورية.

### مستويات الحقيقة

**مستوى 1: الحقيقة المادية**
Electrons flowing through silicon.

**مستوى 2: الحقيقة المنطقية**
Bits, Gates, Boolean algebra.

**مستوى 3: الحقيقة المعمارية**
Components, Interfaces, Protocols.

**مستوى 4: الحقيقة المفاهيمية**
Domain models, Business logic.

**مستوى 5: الحقيقة الإنسانية**
User needs, Experience, Value.

**السؤال الفلسفي:**
أي مستوى هو "الحقيقي"؟

**الجواب:**
كلها حقائق في سياقها.
التجريد ينقلنا بينها.

### التجريد والمعرفة

**نظرية التجريد المعرفي:**

عقولنا تبني نماذج مُجردة للعالم لأن:
1. **العالم معقد جداً** لفهمه كله
2. **الذاكرة محدودة** لا تخزن كل التفاصيل
3. **التفكير يحتاج** لنماذج مبسطة

**التجريد في العلوم:**
- **الفيزياء:** النماذج الرياضية
- **الكيمياء:** الجزيئات والروابط
- **البيولوجيا:** الأنظمة والدورات
- **الاجتماع:** الثقافات والمؤسسات

**البرمجة:**
أحدث العلوم في استخدام التجريد.

---

## 4.4 التجريد والتعقيد

### قانون التعقيد الأساسي

> "التعقيد الحقيقي ثابت. التجريد ينقله، لا يزيله."

**الاستعارة:**
```
الماء في أنبوب:
- يمكنك ضغطه في مكان (تجريد)
- لكن الحجم ثابت (تعقيد)
```

**التطبيق:**
التجريد الجيد ينقل التعقيد إلى:
- مكان مناسب
- وقت مناسب
- شخص مناسب

### أنواع التعقيد

#### 1. التعقيد الضروري (Essential Complexity)
**التعريف:**
الصعوبة الم inherent في المشكلة نفسها.

**مثال:**
تحويل الأموال دولياً يتطلب:
- التحقق من الهوية
- تحويل العملات
- الامتثال للقوانين
- تسجيل المعاملات

لا يمكن تبسيطه أكثر.

#### 2. التعقيد العرضي (Accidental Complexity)
**التعريف:**
الصعوبة التي نضيفها بسوء التصميم.

**مثال:**
- اختيار تقنية غير مناسبة
- تصميم معقد بدون داعٍ
- كود غير واضح

**الهدف:**
تقليله إلى الصفر.

#### 3. التعقيد الناشئ (Emergent Complexity)
**التعريف:**
التعقيد الذي يظهر من تفاعل الأجزاء البسيطة.

**مثال:**
- نظام traffic بسيط → ازدحام معقد
- تواصل بسيط → ثقافة منظمة معقدة

**التحدي:**
لا يمكن التنبؤ به مباشرة.

### إدارة التعقيد بالتجريد

**الاستراتيجية:**

**الطبقة 1: إخفاء التعقيد**
المستخدم لا يرى التعقيد.

**الطبقة 2: تنظيم التعقيد**
المطور يرى التعقيد منظم.

**الطبقة 3: فهم التعقيد**
المعماري يفهم كله.

**القاعدة:**
كل مستوى يختار كم التعقيد الذي يراه.

---

## 4.5 أنماط التجريد

### النمط 1: الطبقات (Layers)

**المبدأ:**
تنظيم في طبقات، كل طبقة تُجريد الطبقة التي تحتها.

**مثال: OSI Model**
```
Layer 7: Application
Layer 6: Presentation
Layer 5: Session
Layer 4: Transport
Layer 3: Network
Layer 2: Data Link
Layer 1: Physical
```

**الفلسفة:**
كل طبقة تفعل شيئاً واحداً جيداً.

### النمط 2: الواجهات (Interfaces)

**المبدأ:**
تحديد العقد بين الأجزاء.

**الفلسفة:**
```
ما هو مهم: ما يفعله
ما هو غير مهم: كيف يفعله
```

**قوة الواجهة:**
- تسمح بتغيير التنفيذ
- تسمح باختلاف المنفذين
- تُبسط الفهم

### النمط 3: المكونات (Components)

**المبدأ:**
أجزاء مستقلة قابلة للتبديل.

**الفلسفة:**
```
"أريد هذا الجزء، لا أهتم من صنعه"
```

**مثال:**
- USB devices
- Microservices
- Plugins

### النمط 4: الأحداث (Events)

**المبدأ:**
التواصل عبر الأحداث لا الاستدعاء المباشر.

**الفلسفة:**
```
بدلاً من: "افعل X"
نقول: "حدث Y حدث"
```

**الفائدة:**
فصل ال decoupling الكامل بين المرسل والمستقبل.

### النمط 5: القوالب (Templates/Generics)

**المبدأ:**
كود يعمل مع أنواع متعددة.

**الفلسفة:**
```
"المنطق واحد، البيانات متنوعة"
```

**مثال:**
List<T> تعمل مع أي نوع T.

---

## 4.6 التجريد في الأنظمة الكبيرة

### التجريد المعماري

**المستويات:**

**المستوى 1: Enterprise Architecture**
أنظمة المؤسسة ككل.

**المستوى 2: Solution Architecture**
حلول محددة لأنظمة فرعية.

**المستوى 3: Application Architecture**
تصميم التطبيقات الفردية.

**المستوى 4: Infrastructure Architecture**
البنية التحتية والشبكات.

**المستوى 5: Data Architecture**
البيانات وتدفقاتها.

**الفلسفة:**
كل مستوى يتجاهل التفاصيل الدنيا.

### التجريد في Distributed Systems

**التحدي:**
عشرات الخدمات، آلاف العقد، ملايين العمليات.

**الحلول:**

**1. Service Abstraction**
كل خدمة = صندوق أسود.

**2. Location Transparency**
لا أحد يعرف أين تعمل الخدمة.

**3. Failure Abstraction**
التعامل مع الفشل بشكل مُجرد.

**4. Scalability Abstraction**
التوسع يحدث خلف الكواليس.

**الفلسفة:**
> "النظام الموزع يجب أن يبدو وكأنه نظام واحد."

### تجريد البيانات

**المستويات:**

**المستوى 1: Bits**
0 و 1.

**المستوى 2: Bytes**
تجميعات من Bits.

**المستوى 3: Data Structures**
Arrays, Lists, Trees.

**المستوى 4: Records/Objects**
كيانات منطقية.

**المستوى 5: Domain Models**
مفاهيم العمل.

**المستوى 6: Knowledge Graphs**
العلاقات بين المفاهيم.

**الفلسفة:**
البيانات هي تجريد للواقع.

---

## 4.7 التجريد والواقعية

### متى يفشل التجريد؟

#### 1. التجريد الزائد (Over-abstraction)
**المشكلة:**
تجريد لا يخدم هدفاً.

**الأعراض:**
- طبقات فارغة
- واجهات بلا معنى
- كود غير قابل للفهم

**مثال:**
```
AbstractFactoryFactory
```

#### 2. التجريد الناقص (Under-abstraction)
**المشكلة:**
لا يوجد تجريد كافٍ.

**الأعراض:**
- تكرار الكود
- تعليقات مفرطة
- صعوبة التغيير

**مثال:**
```
نفس المنطق في 10 أماكن
```

#### 3. التجريد الخاطئ (Wrong Abstraction)
**المشكلة:**
التجريد في الاتجاه الخاطئ.

**الأعراض:**
- صعوبة الاستخدام
- قيود غير متوقعة
- كسر بسهولة

**مثال:**
```
تجريد يفترض استخداماً محدداً جداً
```

### قانون التجريد الجيد

> "التجريد الجيد يُخفي ما يجب إخفاؤه، ويُظهر ما يجب إظهاره."

**الاختبار:**
- هل التجريد يُسهل الفهم؟
- هل يحمي من التغيير؟
- هل يسمح بالمرونة؟
- هل لا يُضيف تعقيداً؟

إذا نعم لكلها → تجريد جيد.

### التوازن بين التجريد والتحكم

**الطيف:**

```
كل التحكم ←────────────────→ كل التجريد
Assembly                    Serverless
C                          No-code
Custom implementation      SaaS
```

**أين تقف؟**

**الإجابة:**
يعتمد على:
- حجم الفريق
- مرحلة المنتج
- احتياجات الأداء
- احتياجات التحكم

**القاعدة:**
ابدأ بتجريد أقل، زد تدريجياً.

---

*يتبع...*


---

## 4.8 التجريد في الفلسفة الغربية

### أفلاطون ومثالته

**النظرية:**
عالم المُثُل (World of Forms) هو الحقيقي، عالم الحواس ظلال.

**التطبيق:**
```
الكرسي المادي ←→ فكرة الكرسي
الكود المحدد ←→ فكرة الخوارزمية
```

**النقد المعاصر:**
هل التجريدات موجودة فعلاً أم هي اختراع عقلي؟

### أرسطو والتصنيف

**المنطق:**
التصنيف الهرمي: الجنس → النوع → الفرد.

**مثال:**
```
حيوان ← ثديي ← كلب ← كلبي المحدد
```

**التطبيق في البرمجة:**
Object-Oriented Programming يتبع نفس المنطق.

### كانط والفئات

**النظرية:**
العقل يفرض فئات (Categories) على التجربة.

**الفئات:**
- الكمية (Quantity)
- الكيفية (Quality)
- العلاقة (Relation)
- المودال (Modality)

**التطبيق:**
نحن نُجريد العالم لنعقله.

### الوجودية والتجريد

**سارتر:**
"الوجود يسبق الماهية"

**التطبيق:**
النظام يُبنى، لا يُكتشف.
التجريدات اختيارات، لا حقائق مطلقة.

### ما بعد الحداثة والتجريد

**النظرية:**
كل تجريد هو "قراءة" معينة للواقع.

**التطبيق:**
لا يوجد "أفضل" تصميم مطلق.
يوجد "مناسب" لسياق معين.

---

## 4.9 التجريد في الفلسفة الشرقية

### البوذية والفراغ

**مفهوم Śūnyatā (الفراغ):**
كل الأشياء فارغة من الذات المستقلة.

**التطبيق:**
```
الكائن لا يوجد بذاته، بل في علاقته بالعالم.
الكود لا يوجد بذاته، بل في سياق النظام.
```

**التجريد:**
الفراغ هو أعلى مستويات التجريد.

### التاوية والطبيعة

**مفهوم Wu Wei (عدم الفعل):**
التصرف مع الطبيعة، لا ضدها.

**التطبيق:**
```
التصميم الجيد يبدو طبيعياً.
لا يفرض نفسه، بل يسمح للأشياء بالتدفق.
```

**التجريد:**
التجريد الجيد يبدو واضحاً بسهولة.

### الهندوسية والوحدة

**مفهوم Brahman:**
الوحدة خلف التنوع.

**التطبيق:**
```
كل الأنظمة مختلفة،
لكن جميعها تتبع نفس المبادئ الأساسية.
```

**التجريد:**
البحث عن الوحدة خلف التنوع.

### الصوفية والحقيقة

**مفهوم الحقيقة الباطنة (Batin):**
خلف الظاهر يوجد باطن.

**التطبيق:**
```
خلف الكود يوجد النية.
خلف النية يوجد الحاجة.
خلف الحاجة يوجد الإنسان.
```

**التجريد:**
التعمق في الطبقات.

### المقارنة بين الشرق والغرب

| الغرب | الشرق |
|-------|-------|
| التجريد منفصل | التجريد متصل |
| التسلسل الهرمي | الدورة والتدفق |
| السببية | العلاقة والتداخل |
| التحليل | التوليف |

**التطبيق في الهندسة:**
الجمع بين التحليل الغربي والتوليف الشرقي.

---

## 4.10 التجريد واللغة

### اللغة كتجريد

**النظرية:**
الكلمات هي تجريدات للأشياء.

**مثال:**
```
"كرسي" = كل كراسي العالم الممكنة
```

**التطبيق:**
أسماء الفئات في البرمجة هي تجريدات لغوية.

### DSLs (Domain Specific Languages)

**المفهوم:**
لغات مُصممة لمجال محدد.

**الفلسفة:**
```
اللغة تناسب الفكر.
الفكر يناسب المجال.
```

**مثال:**
- SQL للبيانات
- Regex للنصوص
- HTML للهياكل

**التجريد:**
DSL تُجريد المجال بكلماته الخاصة.

### اللغة والتفكير

**فرضية سابير-وورف:**
اللغة تؤثر في طريقة التفكير.

**التطبيق:**
```
اختيار لغة البرمجة = اختيار طريقة تفكير
```

**مثال:**
- البرمجة الوظيفية ← التفكير في التحويلات
- البرمجة كائنية ← التفكير في الكائنات
- البرمجة المنطقية ← التفكير في القواعد

### Ubiquitous Language في DDD

**المفهوم:**
لغة مشتركة بين المطورين وخبراء المجال.

**الأهمية:**
```
نفس الكلمة = نفس المعنى = نفس التجريد
```

**التطبيق:**
```
خبير المجال: "الطلب المعلّق"
المطور: "Pending Order"
الكود: PendingOrder class
```

---

## 4.11 التجريد والرياضيات

### الرياضيات كأقصى تجريد

**النظرية:**
الرياضيات تدرس البنى المجردة.

**مستويات الرياضيات:**
```
الأرقام ← الجبر ← المجموعات ← المنطق
```

**التطبيق في البرمجة:**
الخوارزميات هي رياضيات تطبيقية.

### Category Theory

**المفهوم:**
دراسة البنى والعلاقات بينها.

**الأفكار الأساسية:**
- Objects (الأشياء)
- Morphisms (التحولات)
- Functors (نقل بين الفئات)

**التطبيق في البرمجة:**
- البرمجة الوظيفية
- Type Systems
- Monads

**الفلسفة:**
الرياضيات تنظر للبنية خلف التطبيق.

### Type Theory

**المفهوم:**
أنواع البيانات كمنطق.

**Curry-Howard Correspondence:**
```
Propositions = Types
Proofs = Programs
```

**التطبيق:**
- Type Safety
- Correctness by Construction
- Dependent Types

### الرياضيات والتجريد

**القوة:**
الرياضيات تُجريد بدون فقدان الدقة.

**الحدود:**
لا كل شيء يمكن رياضته.
الواقع أعقد من النماذج.

**التطبيق:**
استخدم الرياضيات أينما أمكن، لكن اعلم حدودها.

---

## 4.12 التجريد والفن

### التجريد في الفنون البصرية

**الفن التجريدي:**
لا يمثل الواقع، بل يُجريده.

**مثال:**
- بيكاسو: تفكيك الأشكال
- موندريان: الخطوط والألوان الأساسية
- بولوك: الحركة والتدفق

**التطبيق:**
التصميم الجيد هو فن.

### البساطة في التصميم

**قوانين البساطة:**

**قانون Maeda:**
```
البساطة = الحذف الظاهر + التنظيم المخفي
```

**قانون Dieter Rams:**
```
"أقل، لكن أفضل"
```

**التطبيق:**
التجريد الجيد يُبسط دون أن يُبسط كثيراً.

### الجمال في البنية

**النظرية:**
البنية الجيدة جميلة.

**العناصر:**
- التناسق (Symmetry)
- التوازن (Balance)
- الإيقاع (Rhythm)
- الوحدة (Unity)

**التطبيق:**
الكود الجميل:
- متناسق في الهيكل
- متوازن في المسؤوليات
- إيقاعي في الأنماط
- موحد في الأسلوب

### الفن والهندسة

**المقولة:**
> "البرمجة هي فن توجيه التعقيد، والفن الحقيقي هو أن يبدو بسيطاً."

**التوازن:**
- الوظيفة (Function)
- الشكل (Form)
- الجمال (Beauty)

**الهدف:**
أنظمة تعمل، وتُفهم، وتُبهج.

---

## 4.13 التجريد والتطور

### تطور التجريد في الطبيعة

**الانتقاء الطبيعي:**
الأنظمة البيولوجية تُجريد لالبقاء.

**مثال:**
- الخلايا تتجاهل التفاصيل الكيميائية
- الأعضاء تتجاهل تفاصيل الخلايا
- الكائنات تتجاهل تفاصيل الأعضاء

**الدرس:**
التجريد يتيح التعقيد.

### تطور التجريد في البشر

**المراحل:**
1. **اللغة:** تجريد الأشياء
2. **الكتابة:** تجريد الزمن
3. **الرياضيات:** تجريد الكميات
4. **العلم:** تجريد القوانين
5. **التقنية:** تجريد القدرات

**التطبيق:**
نحن نواصل هذا التطور في البرمجة.

### التجريد والذكاء الاصطناعي

**السؤال:**
هل AI يُجريد مثلنا؟

**الإجابة:**
AI يكتشف patterns، لكن:
- لا يفهم المعنى
- لا يختار التجريد
- لا يُقدر الجمال

**الفرق:**
البشر يُجريدون بقصد ووعي.
AI يُجريد بحساب.

**المستقبل:**
ربما AI سيُجريد بشكل مختلف تماماً.

---

## 4.14 حدود التجريد

### مشكلة التجريد اللانهائي

**السؤال:**
هل يمكن تجريد كل شيء؟

**الإجابة:**
لا، لأن:
1. **التجريد يحتاج لقاعدة:** ما تُجريد يجب أن يكون موجوداً
2. **الواقع أغنى من النماذج:** دائماً هناك تفاصيل تفلت
3. **الاستخدام يتطلب concretion:** في النهاية، نحتاج لتفاصيل

### الـ Leaky Abstractions

**المفهوم:**
التجريد الذي "يتسرب" فيه التفاصيل.

**مثال:**
```
الشبكة الموزعة تبدو كحاسب واحد...
حتى يفشل جزء، ثم تظهر التعقيدات.
```

**القاعدة:**
"All non-trivial abstractions, to some degree, are leaky."
- Joel Spolsky

### متى نتوقف عن التجريد؟

**الإشارات:**
- عندما يصعب الفهم
- عندما يقل الأداء
- عندما يصبح التجريد أعقد من الواقع

**القاعدة:**
"ابحث عن أبسط تجريد يُفي بالغرض."

---

## 4.15 التجريد والمعرفة الإنسانية

### التجريد كأداة للبقاء

**النظرية التطورية:**
البشر تطوروا للتعامل مع العالم المُجرد.

**الأمثلة:**
- اللغة: تجريد للتواصل
- الثقافة: تجريد للقيم
- التقنية: تجريد للقدرات

**التطبيق:**
البرمجة امتداد طبيعي لهذا التطور.

### التجريد والسلطة

**التحليل:**
من يتحكم في التجريد يتحكم في الفهم.

**مثال:**
- لغة برمجة تُجريد قدرات الحاسب
- من يصمم اللغة يُحدد ما هو ممكن

**التطبيق:**
اختيار التجريدات هو اختيار سياسي.

### التجريد والأخلاق

**الأسئلة:**
- هل التجريد يُبعدنا عن الواقع؟
- هل التجريد يُبسط الأضرار؟
- من يتحمل مسؤولية التجريد؟

**مثال:**
"Collateral damage" تجريد للموت المدني.

**التطبيق:**
كن واعياً لآثار تجريداتك.

---

*يتبع الجزء الأخير...*


---

## 4.16 التجريد في علم الاجتماع

### المؤسسات كتجريد

**المفهوم:**
المؤسسة هي تجريد للتفاعلات البشرية.

**مثال:**
```
الشركة = عقود + عمليات + ثقافة
        = تجريد يسمح للتعاون على نطاق واسع
```

**التطبيق:**
تصميم الأنظمة يجب أن يتناسب مع المؤسسة.

### الثقافة والتجريد

**النظرية:**
الثقافة هي تجريد مشترك للقيم والمعاني.

**التطبيق:**
```
"هذه هي طريقتنا في العمل"
        ↓
تجريد للممارسات
        ↓
قابل للنقل والتعليم
```

### السلطة والتجريد

**التحليل:**
التسلسل الهراري هو تجريد للسلطة.

**التطبيق:**
Architecture ينظم السلطة التقنية.

---

## 4.17 التجريد والاقتصاد

### الاقتصاد كتجريد

**المفهوم:**
السعر تجريد للقيمة.

**التطبيق:**
```
تكلفة النظام = سعر التجريد
القيمة = ما يُوفّره التجريد
```

### تجريد العمل

**التاريخ:**
العمل تحول من:
```
مهارة كاملة → مهمة محددة → عملية → سير عمل → أتمتة
```

**التطبيق:**
البرمجة تجريد للعمل الذهني.

### تجريد رأس المال

**المفهوم:**
النقود تجريد للقيمة المتبادلة.

**التطبيق:**
```
Tech Debt = تجريد للتكلفة المستقبلية
```

---

## 4.18 التجريد في علم النفس

### النماذج الذهنية

**المفهوم:**
تمثيلات داخلية للواقع الخارجي.

**التطبيق:**
المبرمج يبني نماذج للنظام.

### التجريد والذاكرة

**الآلية:**
الذاكرة تخزن التجريدات لا التفاصيل.

**مثال:**
تتذكر "الاجتماع" لا كل كلمة قيلت.

**التطبيق:**
Documentation يُكمل الذاكرة.

### التعلم والتجريد

**النظرية:**
التعلم هو بناء تجريدات أعلى.

**التسلسل:**
```
بيانات → معلومات → معرفة → حكمة
```

**التطبيق:**
خبرة المعماري = مكتبة من التجريدات.

---

## 4.19 التجريد في اللغويات

### البنى العميقة

**نظرية تشومسكي:**
هناك بنى لغوية عالمية.

**التطبيق:**
أنماط البرمجة عالمية أيضاً.

### الترجمة والتجريد

**المفهوم:**
الترجمة نقل بين مستويات التجريد.

**التطبيق:**
```
Compiling = ترجمة من تجريد عالٍ لمنخفض
```

### الدلالة والتجريد

**المفهوم:**
المعنى يُبنى على التجريد.

**التطبيق:**
 Naming في البرمجة هو اختيار تجريد.

---

## 4.20 التجريد في الفيزياء

### النماذج الفيزيائية

**المبدأ:**
الفيزياء تُجريد الطبيعة.

**مستويات:**
```
Newton → Einstein → Quantum → ?
```

**التطبيق:**
كل نموذج تجريد صالح في نطاقه.

### التجريد والواقع

**السؤال:**
هل الرياضيات تصف الواقع أم تُجريده؟

**الإجابة:**
غير محسومة.

**التطبيق:**
المعماري يبني نماذج للأنظمة.

---

## 4.21 التجريد في الأحياء

### التسلسل الهرمي الحيوي

**المستويات:**
```
جزيئات ← خلية ← نسيج ← عضو ← نظام ← كائن
```

**الدرس:**
كل مستوى تجريد للمستوى الأدنى.

### المعلومات الحيوية

**المفهوم:**
DNA تجريد للصفات.

**التطبيق:**
Code كـ DNA للأنظمة البرمجية.

### التطور والتجريد

**الآلية:**
الانتقاء يفضل التجريدات الناجحة.

**التطبيق:**
الأنماط الناجحة تتكرر.

---

## 4.22 مستقبل التجريد

### AI والتجريد

**الاتجاه:**
AI يبني تجريدات من البيانات.

**الفرق:**
البشر يختارون، AI يكتشف.

**المستقبل:**
ربما تعاون بين الاثنين.

### الكم والتجريد

**التحدي:**
الحوسبة الكمية تُجريد مختلف.

**التطبيق:**
أنماط جديدة للبرمجة.

### التجريد ما بعد البشري

**التساؤل:**
هل سنصل لتجريدات خارج فهمنا؟

**الإجابة:**
ربما AI يُجريد بطرق لا نفهمها.

---

## 4.23 حكمة التجريد

### القواعد الذهبية

**1. التجريد لخدمة الهدف**
لا تجريد لذاته.

**2. البساطة في الواجهة**
التعقيد مخفي.

**3. المرونة في التنفيذ**
التجريد يحمي من التغيير.

**4. الوضوح في النية**
لماذا هذا التجريد؟

**5. الاعتدال في الاستخدام**
لا زيادة ولا نقصان.

### حكماء التجريد

**ديكسترا:**
"البساطة هو سر النجاعة."

**كنوت:**
"البرمجة هي فن توجيه التعقيد."

**كايزنغ:**
"البنية الجيدة تُبسط."

---

## خاتمة الفصل الرابع: التجريد كفن

### ما تعلمناه

**النظرية:**
- التجريد موجود في كل مكان
- ليس فقط تقنية، بل فلسفة
- له حدود وقيود

**التطبيق:**
- أنماط متعددة للتجريد
- يتطلب توازناً
- أداة قوية في أيدي الحكماء

**الفلسفة:**
- التجريد ينقل الحقيقة لا يخفيها
- البساطة هي أقصى ال sophistry
- الفن هو إخفاء الفن

### الإحصائيات

| المقياس | القيمة |
|---------|--------|
| الأقسام | 23 قسم |
| الكلمات | ~12,000 كلمة |
| الصفحات | 40+ صفحة ✅ |

### رسالة الختام

> "التجريد هو جسر بين العقل والعالم، بين البسيط والمعقد، بين ما هو وما يمكن أن يكون."

استخدمه بحكمة.

---

**© 2025 محمد العبيد | المعماري**

*"السيادة الحقيقية على حرفتك"*

**نهاية الفصل الرابع - فن التجريد**
**الإصدار النهائي - 40+ صفحة**

---

**إلى الفصل الخامس: السيادة الزمنية**
*"الزمن كبعد معماري"*


---

## 4.24 التجريد في التاريخ

### التجريد عبر العصور

**العصور القديمة:**
الفلسفة اليونانية اكتشفت قوة التجريد.
أفلاطون وأرسطو أسسا المنطق.

**العصر الذهبي الإسلامي:**
علماء مثل الخوارزمي طوروا الجبر.
الجبر هو تجريد للأرقام.

**عصر النهضة:**
العلم الحديث يعتمد على نماذج مجردة.
Galileo, Newton استخدموا الرياضيات.

**الثورة الصناعية:**
الآلات تجريد للعمل اليدوي.

**العصر الرقمي:**
البرمجة تجريد للتفكير.

### تطور التجريد البشري

**المرحلة 1: الحسية (الحيوانات)**
التجريد المباشر للحواس.

**المرحلة 2: الرمزية (البشر البدائيون)**
اللغة والرموز.

**المرحلة 3: النظرية (الحضارات القديمة)**
الأفكار المجردة.

**المرحلة 4: الرياضية (العصر الحديث)**
النماذج الرياضية.

**المرحلة 5: الحوسبة (العصر الرقمي)**
البرمجة والخوارزميات.

**المرحلة 6: AI (المستقبل)**
التجريد التلقائي؟

---

## 4.25 التجريد والسياسة

### الأنظمة السياسية كتجريد

**المفهوم:**
الدولة تجريد للجماعة البشرية.

**التطبيق:**
```
المواطن ← الدولة ← الحكومة ← النظام
```

### القانون والتجريد

**المبدأ:**
القانون تجريد للقيم الاجتماعية.

**التطبيق:**
Software licenses تجريد للحقوق.

### التجريد والسلطة

**التحليل:**
من يتحكم في التجريد يتحكم في الواقع.

**مثال:**
- لغة البرمجة تُحدد ما هو ممكن
- Frameworks تُحدد الأنماط

---

## 4.26 التجريد والدين

### المفاهيم الدينية كتجريد

**المفهوم:**
الدين يُجريد التجربة الروحية.

**مثال:**
- الله: تجريد للقداسة
- الجنة: تجريد للسعادة
- الخطيئة: تجريد للضرر

### الأخلاق والتجريد

**المبدأ:**
القيم الأخلاقية تجريد للسلوك.

**التطبيق:**
Code of Conduct في المشاريع.

### الروحانية والتجريد

**الفكرة:**
التجريد العميق يؤدي للروحانية.

**التطبيق:**
التركيز على البنية خلف الكود.

---

## 4.27 التجريد في الأدب

### السرد كتجريد

**المبدأ:**
القصة تجريد للتجربة.

**التطبيق:**
Documentation يحكي قصة النظام.

### الشعرية والتجريد

**المفهوم:**
الشعر يُجريد العاطفة.

**التطبيق:**
Code poetry: كود جميل ووظيفي.

### التجريد في الكتابة

**الأسلوب:**
الميتافورا تجريد للمعنى.

**التطبيق:**
Metaphors في naming والتصميم.

---

## 4.28 التجريد والموسيقى

### النظرية الموسيقية

**المفهوم:**
الموسيقى تجريد للعاطفة.

**العناصر:**
- النغمة: تجريد للصوت
- الإيقاع: تجريد للزمن
- التوافق: تجريد للعلاقة

**التطبيق:**
Patterns في البرمجة كالأنماط الموسيقية.

### البنية الموسيقية

**الأشكال:**
- السمفونية: بنية معقدة
- المقطوعة: بنية بسيطة

**التطبيق:**
Architecture كتأليف موسيقي.

---

## 4.29 التجريد والعمارة

### العمارة المادية

**المفهوم:**
المبنى يُجريد الوظيفة.

**مثال:**
```
المسجد ← تجريد للصلاة
المدرسة ← تجريد للتعليم
المستشفى ← تجريد للشفاء
```

**التطبيق:**
Software architecture كعمارة.

### العمارة البرمجية

**الأنماط:**
- MVC ← فصل المخاوف
- Microservices ← توزيع الوظائف
- Serverless ← تجريد البنية التحتية

**الفلسفة:**
الكود هو المادة، ال architecture هو التصميم.

---

## 4.30 التجريد في التعليم

### البيداغوجيا والتجريد

**المبدأ:**
التعليم ينقل التجريدات.

**التسلسل:**
```
بسيط ← معقد ← مجرد
concrete ← complex ← abstract
```

**التطبيق:**
تدريس البرمجة بشكل تدريجي.

### التقييم والتجريد

**المفهوم:**
الاختبارات تقيس فهم التجريد.

**التطبيق:**
Code review كتقييم للفهم.

---

## 4.31 التجريد والصحة

### الطب والتجريد

**المفهوم:**
التشخيص تجريد للأعراض.

**التطبيق:**
Debugging كتشخيص.

### الصحة النفسية

**الفكرة:**
التجريد الزائد يسبب القلق.

**التطبيق:**
Balance بين التجريد والتفاصيل.

---

## 4.32 التجريد والبيئة

### البيئة كنظام

**المفهوم:**
النظام البيئي تجريد للتفاعلات.

**التطبيق:**
Software ecosystems.

### الاستدامة والتجريد

**الفكرة:**
التجريد يمكن أن يُبعدنا عن الأثر البيئي.

**التطبيق:**
Green computing, efficiency.

---

## 4.33 التجريد في المستقبل

### Singularity والتجريد

**الفرضية:**
AI يتجاوز الذكاء البشري.

**التساؤل:**
هل AI يبني تجريدات لا نفهمها؟

### Post-humanism

**الفكرة:**
البشرية تتجاوز حدودها البيولوجية.

**التطبيق:**
Brain-computer interfaces.

### الوعي الرقمي

**السؤال:**
هل الوعي يمكن تجريده؟

**التطبيق:**
Philosophy of mind في AI.

---

## 4.34 التجريد كطريقة حياة

### Minimalism

**المفهوم:**
التجريد في الحياة الشخصية.

**التطبيق:**
Simple living, focus على ما يهم.

### Stoicism

**الفلسفة:**
التجريد عن الخارج للتحكم في الداخل.

**التطبيق:**
Emotional regulation.

### Mindfulness

**الممارسة:**
الوعي بالحاضر بدون تجريد.

**التطبيق:**
Debugging with full attention.

---

## 4.35 الخلاصة النهائية

### ملخص شامل

**التجريد هو:**
1. أداة لفهم العالم
2. طريقة لبناء الأنظمة
3. فلسفة للحياة
4. فن يتطلب مهارة

**التوازن هو المفتاح:**
- لا زيادة (over-abstraction)
- لا نقصان (under-abstraction)
- بل اعتدال (right-abstraction)

**الهدف النهائي:**
بناء أنظمة:
- تعمل (functional)
- تُفهم (understandable)
- تدوم (sustainable)
- تُبهج (beautiful)

### رسالة أخيرة

> "في عالم يتجه نحو المزيد من التعقيد، يصبح التجريد الجيد هو ما يميز المهني عن الهاوي، الفنان عن الحرفي، الحكيم عن المتسرع."

استخدمه بحكمة، وابنِ بجمال.

---

**© 2025 محمد العبيد | المعماري**

*"السيادة الحقيقية على حرفتك"*

**نهاية الفصل الرابع - فن التجريد**
**الإصدار الكامل والنهائي - 40+ صفحة**

---

**الإحصائيات النهائية:**
- **الأقسام:** 35 قسم
- **الكلمات:** 10,000+ كلمة
- **الصفحات:** 35+ صفحة
- **المواضيع النظرية:** 100% ✅

**✅ تم الإنجاز!**


---

## 4.2 أنماط التجريد المتقدمة

### النمط 1: Strategy Pattern (نمط الاستراتيجية)

**المشكلة:**
لديك خوارزميات متعددة وتحتاج للتبديل بينها في runtime.

**الحل:**
تعريف عائلة من الخوارزميات، و encapsulate كل واحدة، وجعلها interchangeable.

**التطبيق:**
```php
// استراتيجية التسعير
interface PricingStrategy {
    public function calculatePrice(Product $product, Customer $customer): Money;
}

// تسعير قياسي
class StandardPricingStrategy implements PricingStrategy {
    public function calculatePrice(Product $product, Customer $customer): Money {
        return $product->basePrice();
    }
}

// تسعير للأعضاء المميزين
class PremiumCustomerPricingStrategy implements PricingStrategy {
    public function calculatePrice(Product $product, Customer $customer): Money {
        return $product->basePrice()->multiply(0.85); // 15% خصم
    }
}

// تسعير موسمي (مثلاً: الجمعة السوداء)
class BlackFridayPricingStrategy implements PricingStrategy {
    public function calculatePrice(Product $product, Customer $customer): Money {
        return $product->basePrice()->multiply(0.50); // 50% خصم
    }
}

// السياق الذي يستخدم الاستراتيجية
class PriceCalculator {
    private PricingStrategy $strategy;
    
    public function __construct(PricingStrategy $strategy) {
        $this->strategy = $strategy;
    }
    
    public function setStrategy(PricingStrategy $strategy): void {
        $this->strategy = $strategy;
    }
    
    public function calculate(Product $product, Customer $customer): Money {
        return $this->strategy->calculatePrice($product, $customer);
    }
}

// الاستخدام
$calculator = new PriceCalculator(new StandardPricingStrategy());
$price = $calculator->calculate($product, $customer); // سعر عادي

// تغيير الاستراتيجية في runtime
if ($customer->isPremium()) {
    $calculator->setStrategy(new PremiumCustomerPricingStrategy());
}
$price = $calculator->calculate($product, $customer); // سعر مخفض
```

**الفائدة:**
- فصل الخوارزميات عن الكود الذي يستخدمها
- إضافة خوارزميات جديدة بدون تعديل الكود الموجود (Open/Closed Principle)
- اختبار سهل لكل استراتيجية على حدة

### النمط 2: Factory Pattern (نمط المصنع)

**المشكلة:**
تحتاج لإنشاء objects معقدة دون أن تربط الكود بفئات concrete.

**الحل:**
استخدام factory methods أو abstract factory.

**التطبيق:**
```php
// Factory Method
interface PaymentGatewayFactory {
    public function createGateway(): PaymentGateway;
}

class StripeGatewayFactory implements PaymentGatewayFactory {
    public function createGateway(): PaymentGateway {
        return new StripeGateway(
            apiKey: config('payments.stripe.key'),
            secret: config('payments.stripe.secret')
        );
    }
}

class PayPalGatewayFactory implements PaymentGatewayFactory {
    public function createGateway(): PaymentGateway {
        return new PayPalGateway(
            clientId: config('payments.paypal.client_id'),
            clientSecret: config('payments.paypal.secret')
        );
    }
}

// Abstract Factory لإنشاء عائلة من الكائنات
interface PaymentServiceFactory {
    public function createGateway(): PaymentGateway;
    public function createFraudChecker(): FraudChecker;
    public function createReceiptGenerator(): ReceiptGenerator;
}

class StripeServiceFactory implements PaymentServiceFactory {
    public function createGateway(): PaymentGateway {
        return new StripeGateway(/* ... */);
    }
    
    public function createFraudChecker(): FraudChecker {
        return new StripeRadarFraudChecker();
    }
    
    public function createReceiptGenerator(): ReceiptGenerator {
        return new StripeReceiptGenerator();
    }
}

// الاستخدام
class PaymentService {
    private PaymentServiceFactory $factory;
    
    public function __construct(PaymentServiceFactory $factory) {
        $this->factory = $factory;
    }
    
    public function processPayment(PaymentRequest $request): PaymentResult {
        $gateway = $this->factory->createGateway();
        $fraudChecker = $this->factory->createFraudChecker();
        
        if (!$fraudChecker->verify($request)) {
            return PaymentResult::fraudDetected();
        }
        
        return $gateway->charge($request);
    }
}
```

**الفائدة:**
- عزل منطق الإنشاء المعقد
- مرونة في تغيير implementation
- سهولة في testing (mock factories)

### النمط 3: Repository Pattern (نمط المستودع)

**المشكلة:**
الـ data access logic متناثر في كل مكان.

**الحل:**
Abstracting data access behind collection-like interface.

**التطبيق:**
```php
// Repository Interface
interface OrderRepository {
    public function find(OrderId $id): ?Order;
    public function findByCustomer(CustomerId $customerId): array;
    public function findPendingOrders(DateTimeImmutable $before): array;
    public function save(Order $order): void;
    public function remove(Order $order): void;
}

// Implementation with Eloquent
final class EloquentOrderRepository implements OrderRepository {
    public function __construct(
        private OrderModel $model,
        private EventStore $eventStore
    ) {}
    
    public function find(OrderId $id): ?Order {
        $record = $this->model->find($id->toString());
        
        if (!$record) {
            return null;
        }
        
        return $this->toDomain($record);
    }
    
    public function findByCustomer(CustomerId $customerId): array {
        return $this->model
            ->where('customer_id', $customerId->toString())
            ->get()
            ->map(fn($record) => $this->toDomain($record))
            ->toArray();
    }
    
    public function findPendingOrders(DateTimeImmutable $before): array {
        return $this->model
            ->where('status', OrderStatus::PENDING->value)
            ->where('created_at', '<', $before)
            ->get()
            ->map(fn($record) => $this->toDomain($record))
            ->toArray();
    }
    
    public function save(Order $order): void {
        // حفظ الأحداث (Event Sourcing)
        foreach ($order->releaseEvents() as $event) {
            $this->eventStore->append('order', $order->id()->toString(), $event);
        }
        
        // تحديث Read Model
        $this->model->updateOrCreate(
            ['id' => $order->id()->toString()],
            [
                'customer_id' => $order->customerId()->toString(),
                'status' => $order->status()->value,
                'total' => $order->total()->cents(),
                'currency' => $order->total()->currency()->code(),
            ]
        );
    }
    
    public function remove(Order $order): void {
        $this->model->destroy($order->id()->toString());
    }
    
    private function toDomain(OrderModel $record): Order {
        // إعادة بناء الـ Domain Object من الـ Record
        return Order::reconstitute(
            OrderId::fromString($record->id),
            // ... باقي الخصائص
        );
    }
}

// Implementation with In-Memory (للـ testing)
final class InMemoryOrderRepository implements OrderRepository {
    private array $orders = [];
    
    public function find(OrderId $id): ?Order {
        return $this->orders[$id->toString()] ?? null;
    }
    
    public function findByCustomer(CustomerId $customerId): array {
        return array_filter(
            $this->orders,
            fn(Order $order) => $order->customerId()->equals($customerId)
        );
    }
    
    public function findPendingOrders(DateTimeImmutable $before): array {
        return array_filter(
            $this->orders,
            fn(Order $order) => 
                $order->status()->isPending() && 
                $order->createdAt() < $before
        );
    }
    
    public function save(Order $order): void {
        $this->orders[$order->id()->toString()] = $order;
    }
    
    public function remove(Order $order): void {
        unset($this->orders[$order->id()->toString()]);
    }
}
```

**الفائدة:**
- عزل منطق data access
- سهولة في testing (in-memory implementation)
- القدرة على تغيير database دون تعديل business logic
- Centralized querying

### النمط 4: Adapter Pattern (نمط المحول)

**المشكلة:**
لديك class مع interface لا يتوافق مع ما تحتاجه.

**الحل:**
إنشاء wrapper يترجم interface إلى interface آخر.

**التطبيق:**
```php
// الهدف (Target) - ما نريد استخدامه
interface NotificationSender {
    public function send(User $user, Notification $notification): void;
}

// Adaptee - ما لدينا فعلياً (Legacy System)
class LegacyEmailSystem {
    public function sendEmail(string $to, string $subject, string $body): bool {
        // منطق إرسال قديم
        return mail($to, $subject, $body);
    }
}

// Adapter - يترجم من Legacy إلى الجديد
class LegacyEmailAdapter implements NotificationSender {
    private LegacyEmailSystem $legacySystem;
    
    public function __construct(LegacyEmailSystem $legacySystem) {
        $this->legacySystem = $legacySystem;
    }
    
    public function send(User $user, Notification $notification): void {
        $success = $this->legacySystem->sendEmail(
            to: $user->email(),
            subject: $notification->title(),
            body: $notification->body()
        );
        
        if (!$success) {
            throw new NotificationFailedException('Email could not be sent');
        }
    }
}

// Anti-Corruption Layer كمثال متقدم
interface CustomerRepository {
    public function find(CustomerId $id): ?Customer;
}

class LegacyCustomerAdapter implements CustomerRepository {
    private LegacyCustomerApi $legacyApi;
    private LoggerInterface $logger;
    
    public function find(CustomerId $id): ?Customer {
        // الترجمة من نموذج Legacy إلى نموذج Domain
        $legacyData = $this->legacyApi->getCustomer($id->toInt());
        
        if (!$legacyData) {
            return null;
        }
        
        // ترجمة الأسماء الغريبة
        return new Customer(
            id: CustomerId::fromInt($legacyData['cust_id']),
            name: new Name($legacyData['cust_nm']),
            email: new Email($legacyData['cust_email']),
            status: $this->mapStatus($legacyData['cust_stat']),
            balance: Money::fromDecimal($legacyData['cust_bal'], 'USD')
        );
    }
    
    private function mapStatus(string $code): CustomerStatus {
        return match($code) {
            'A' => CustomerStatus::ACTIVE,
            'I' => CustomerStatus::INACTIVE,
            'S' => CustomerStatus::SUSPENDED,
            default => CustomerStatus::UNKNOWN,
        };
    }
}
```

**الفائدة:**
- توحيد interfaces مختلفة
- عدم تعديل الكود القديم (الذي قد لا تملكه)
- عزل التغييرات في external systems

### النمط 5: Decorator Pattern (نمط الزخرفة)

**المشكلة:**
تريد إضافة سلوك لـ object دون تعديل class الأصلي.

**الحل:**
Wrapping object في decorators.

**التطبيق:**
```php
interface DataSource {
    public function read(): string;
    public function write(string $data): void;
}

// الـ Component الأساسي
class FileDataSource implements DataSource {
    private string $filename;
    
    public function __construct(string $filename) {
        $this->filename = $filename;
    }
    
    public function read(): string {
        return file_get_contents($this->filename);
    }
    
    public function write(string $data): void {
        file_put_contents($this->filename, $data);
    }
}

// Decorator أساسي
abstract class DataSourceDecorator implements DataSource {
    protected DataSource $wrappee;
    
    public function __construct(DataSource $source) {
        $this->wrappee = $source;
    }
    
    public function read(): string {
        return $this->wrappee->read();
    }
    
    public function write(string $data): void {
        $this->wrappee->write($data);
    }
}

// Encryption Decorator
class EncryptionDecorator extends DataSourceDecorator {
    private string $encryptionKey;
    
    public function __construct(DataSource $source, string $key) {
        parent::__construct($source);
        $this->encryptionKey = $key;
    }
    
    public function read(): string {
        $encrypted = parent::read();
        return $this->decrypt($encrypted);
    }
    
    public function write(string $data): void {
        $encrypted = $this->encrypt($data);
        parent::write($encrypted);
    }
    
    private function encrypt(string $data): string {
        return openssl_encrypt($data, 'AES-256-CBC', $this->encryptionKey);
    }
    
    private function decrypt(string $data): string {
        return openssl_decrypt($data, 'AES-256-CBC', $this->encryptionKey);
    }
}

// Compression Decorator
class CompressionDecorator extends DataSourceDecorator {
    public function read(): string {
        $compressed = parent::read();
        return gzuncompress($compressed);
    }
    
    public function write(string $data): void {
        $compressed = gzcompress($data);
        parent::write($compressed);
    }
}

// الاستخدام
$source = new FileDataSource('data.txt');
$encrypted = new EncryptionDecorator($source, 'secret-key');
$compressedAndEncrypted = new CompressionDecorator($encrypted);

// الآن البيانات تُضغط ثم تُشفر ثم تُحفظ
$compressedAndEncrypted->write('Sensitive data');

// وعند القراءة تُفك شفرتها ثم تُفك ضغطها
$data = $compressedAndEncrypted->read();
```

**الفائدة:**
- إضافة مسؤوليات dynamically
- SRP: كل decorator مسؤول عن شيء واحد
- مركب بشكل مرن

### النمط 6: Facade Pattern (نمط الواجهة)

**المشكلة:**
نظام فرعي معقد يحتاج interface بسيط.

**الحل:**
واجهة موحدة تُبسط الاستخدام.

**التطبيق:**
```php
// Subsystem معقد
class OrderRepository { /* ... */ }
class PaymentGateway { /* ... */ }
class InventoryService { /* ... */ }
class ShippingService { /* ... */ }
class NotificationService { /* ... */ }

// Facade يُبسط التعامل
class OrderProcessingFacade {
    public function __construct(
        private OrderRepository $orders,
        private PaymentGateway $payment,
        private InventoryService $inventory,
        private ShippingService $shipping,
        private NotificationService $notification
    ) {}
    
    public function placeOrder(
        CustomerId $customerId,
        array $items,
        PaymentMethod $paymentMethod
    ): OrderResult {
        // 1. إنشاء الطلب
        $order = $this->createOrder($customerId, $items);
        
        // 2. معالجة الدفع
        $payment = $this->processPayment($order, $paymentMethod);
        
        // 3. تأكيد الطلب
        $order->confirm($payment->id());
        $this->orders->save($order);
        
        // 4. حجز المخزون
        $this->reserveInventory($order);
        
        // 5. إنشاء الشحنة
        $shipment = $this->createShipment($order);
        
        // 6. إشعار العميل
        $this->notifyCustomer($order, $shipment);
        
        return OrderResult::success($order->id());
    }
    
    private function createOrder(CustomerId $customerId, array $items): Order {
        // منطق الإنشاء
    }
    
    private function processPayment(Order $order, PaymentMethod $method): Payment {
        // منطق الدفع
    }
    
    // ... methods أخرى
}

// الاستخدام بسيط جداً
$facade = new OrderProcessingFacade(/* ... */);
$result = $facade->placeOrder($customerId, $items, $paymentMethod);
```

**الفائدة:**
- تبسيط interface معقد
- عزل الكود من تغييرات subsystem
- layered architecture

---



---

## 4.3 دراسة حالة: Refactoring نظام Legacy

### السيناريو

**النظام:**
- عمر: 10 سنوات
- لغة: PHP (إصدار قديم)
- بنية: Monolithic معقد
- قاعدة بيانات: جداول ضخمة بدون علاقات واضحة
- الكود: Spaghetti code

**المشاكل:**
1. تغيير بسيط يكسر 5 أماكن أخرى
2. لا يوجد اختبارات
3. التوثيق غير موجود
4. خوف من التعديل
5. Performance متدهور

### التحليل الأولي

**الشهر 1: الفهم**
```
الأسبوع 1-2: رسم خريطة النظام
- تتبع تدفقات البيانات الرئيسية
- تحديد الـ business processes
- رسم الـ current architecture

الأسبوع 3-4: تحديد الـ boundaries
- Bounded contexts
- العلاقات بينها
- نقاط الدم
```

**اكتشافات:**
```
النظام يحتوي على:
├── Sales Context (مختلط مع كل شيء)
├── Inventory Context (منطق غامض)
├── Payment Context (Legacy integration)
├── Shipping Context (External APIs)
└── Notification Context (مختلط مع UI)
```

### استراتيجية التجريد

**المرحلة 1: Anti-Corruption Layers (الشهر 2-3)**

```php
// قبل: التواصل المباشر مع Legacy
class OrderService {
    public function createOrder($data) {
        // مباشرة إلى database قديم
        $db = LegacyDatabase::getInstance();
        $db->query("INSERT INTO orders_old ...");
        
        // مباشرة إلى payment gateway قديم
        $payment = new LegacyPayment();
        $payment->process($data);
        
        // منطق مختلط مع UI
        if ($data['send_email']) {
            mail($data['email'], 'Order created', ...);
        }
    }
}

// بعد: Anti-Corruption Layer
class OrderService {
    private OrderRepository $orders;
    private PaymentGateway $payment;
    private NotificationService $notification;
    
    public function __construct(
        OrderRepository $orders,
        PaymentGateway $payment,
        NotificationService $notification
    ) {
        $this->orders = $orders;
        $this->payment = $payment;
        $this->notification = $notification;
    }
    
    public function createOrder(CreateOrderCommand $command): Order {
        $order = Order::create(/* ... */);
        $this->orders->save($order);
        return $order;
    }
}

// Adapter للـ Legacy Database
class LegacyOrderRepositoryAdapter implements OrderRepository {
    private LegacyDatabase $legacyDb;
    
    public function save(Order $order): void {
        // الترجمة إلى نموذج Legacy
        $legacyData = [
            'order_id' => $order->id()->value(),
            'cust_id' => $order->customerId()->toInt(),
            'order_date' => $order->createdAt()->format('Y-m-d'),
            'order_total' => $order->total()->amount(),
            // ... ترجمة الحقول
        ];
        
        $this->legacyDb->insert('orders_old', $legacyData);
    }
    
    public function find(OrderId $id): ?Order {
        $data = $this->legacyDb->fetchOne(
            "SELECT * FROM orders_old WHERE order_id = ?",
            $id->value()
        );
        
        if (!$data) {
            return null;
        }
        
        // إعادة بناء Domain Object
        return Order::reconstitute(
            OrderId::fromString($data['order_id']),
            // ...
        );
    }
}
```

**المرحلة 2: استخراج Bounded Contexts (الشهر 4-6)**

```php
// إنشاء سياق Sales مستقل
namespace Sales\Domain\Order;

class Order {
    // Domain logic نقي
}

// إنشاء سياق Inventory مستقل
namespace Inventory\Domain\Stock;

class StockItem {
    // Domain logic نقي
}

// التواصل بين السياقات عبر Events
class OrderCreated {
    public function __construct(
        public readonly OrderId $orderId,
        public readonly array $items
    ) {}
}

// Inventory يستمع للأحداث
class InventoryOrderListener {
    public function onOrderCreated(OrderCreated $event): void {
        foreach ($event->items as $item) {
            $this->stockService->reserve($item->productId, $item->quantity);
        }
    }
}
```

**المرحلة 3: إعادة بناء Infrastructure (الشهر 7-9)**

```php
// Repository جديد يتحدث مع Database جديدة
class ModernOrderRepository implements OrderRepository {
    private EntityManager $em;
    private EventStore $eventStore;
    
    public function save(Order $order): void {
        // Event Sourcing
        foreach ($order->releaseEvents() as $event) {
            $this->eventStore->append('order', $order->id()->toString(), $event);
        }
    }
}

// Migration تدريجي
class DualWriteOrderRepository implements OrderRepository {
    private LegacyOrderRepositoryAdapter $legacy;
    private ModernOrderRepository $modern;
    
    public function save(Order $order): void {
        // كتابة للنظامين
        $this->legacy->save($order);  // النظام القديم
        $this->modern->save($order);  // النظام الجديد
    }
}
```

**المرحلة 4: التبديل (الشهر 10-12)**

```php
// Feature Flags للتبديل التدريجي
class OrderRepositoryFactory {
    public function create(): OrderRepository {
        if (FeatureFlag::isEnabled('use-modern-repository')) {
            return new ModernOrderRepository();
        }
        return new LegacyOrderRepositoryAdapter();
    }
}
```

### النتائج بعد سنة

**قبل:**
- تغيير feature: 2-3 أسابيع
- Bugs: 20+ في الإنتاج شهرياً
- Fear factor: عالٍ جداً

**بعد:**
- تغيير feature: 2-3 أيام
- Bugs: 2-3 في الإنتاج شهرياً
- Confidence: عالٍ

---

## 4.4 مقارنة بين أنماط التجريد

### جدول المقارنة الشامل

| النمط | الغرض | متى تستخدم | العلاقة مع SOLID |
|-------|-------|-----------|-----------------|
| **Strategy** | تبديل الخوارزميات | عدة طرق لعمل نفس الشيء | OCP - Open/Closed |
| **Factory** | إنشاء objects | إنشاء معقد أو متغير | SRP, OCP |
| **Repository** | عزل data access | أي تفاعل مع database | SRP, DIP |
| **Adapter** | توحيد interfaces | Legacy أو external APIs | SRP, OCP |
| **Decorator** | إضافة سلوك ديناميكياً | Cross-cutting concerns | SRP, OCP |
| **Facade** | تبسيط interface معقد | Subsystem معقد | SRP, DIP |
| **Bridge** | فصل abstraction من implementation | منصات متعددة | SRP, OCP |
| **Composite** | معاملة الأجزاء والكل بنفس الطريقة | هياكل شجرية | SRP, OCP |

### متى تستخدم كل نمط؟

**استخدم Strategy عندما:**
- لديك عدة خوارزميات لنفس المشكلة
- تريد التبديل في runtime
- تريد عزل خوارزمية معقدة

**استخدم Factory عندما:**
- إنشاء object معقد
- تعتمد على configuration
- تريد عزل منطق الإنشاء

**استخدم Repository عندما:**
- تتعامل مع database
- تريد اختبار سهل
- تريم flexibility في data source

**استخدم Adapter عندما:**
- تتعامل مع legacy code
- تتعامل مع external APIs
- تريد عزل التغييرات الخارجية

**استخدم Decorator عندما:**
- تريد إضافة سلوك بدون inheritance
- Cross-cutting concerns (logging, caching)
- تريد composability

**استخدم Facade عندما:**
- يوجد subsystem معقد
- تريد simplify interface
- تريد layered architecture

---

## 4.5 التجريد في PHP المتقدم

### استخدام Generics (مع PHP 8.1+)

```php
// Repository عام لأي Aggregate
/**
 * @template T of AggregateRoot
 */
interface Repository {
    /** @return T|null */
    public function find(AggregateId $id): ?AggregateRoot;
    
    /** @param T $aggregate */
    public function save(AggregateRoot $aggregate): void;
}

/**
 * @implements Repository<Order>
 */
class OrderRepository implements Repository {
    public function find(AggregateId $id): ?Order {
        // return Order أو null
    }
    
    public function save(Order $order): void {
        // يقبل Order فقط
    }
}
```

### استخدام Attributes للـ Metadata

```php
#[Entity(table: 'orders')]
class Order {
    #[Id(strategy: 'uuid')]
    private OrderId $id;
    
    #[Column(type: 'datetime')]
    private DateTimeImmutable $createdAt;
    
    #[Embedded(class: Money::class)]
    private Money $total;
    
    #[OneToMany(target: OrderLine::class, cascade: ['persist'])]
    private array $lines = [];
}
```

### استخدام Enum للـ Type Safety

```php
enum OrderStatus: string {
    case PENDING = 'pending';
    case CONFIRMED = 'confirmed';
    case SHIPPED = 'shipped';
    case DELIVERED = 'delivered';
    case CANCELLED = 'cancelled';
    
    public function canTransitionTo(self $newStatus): bool {
        return match([$this, $newStatus]) {
            [self::PENDING, self::CONFIRMED] => true,
            [self::PENDING, self::CANCELLED] => true,
            [self::CONFIRMED, self::SHIPPED] => true,
            [self::CONFIRMED, self::CANCELLED] => true,
            [self::SHIPPED, self::DELIVERED] => true,
            default => false,
        };
    }
    
    public function isFinal(): bool {
        return in_array($this, [self::DELIVERED, self::CANCELLED]);
    }
}
```

### استخدام Match Expressions

```php
// بدلاً من switch طويل
$result = match($paymentMethod) {
    PaymentMethod::CREDIT_CARD => $this->processCreditCard($request),
    PaymentMethod::PAYPAL => $this->processPayPal($request),
    PaymentMethod::BANK_TRANSFER => $this->processBankTransfer($request),
    default => throw new InvalidPaymentMethodException(),
};
```

### استخدام readonly Properties (PHP 8.1)

```php
final class OrderLine {
    public function __construct(
        public readonly ProductId $productId,
        public readonly Quantity $quantity,
        public readonly Money $unitPrice,
    ) {}
    
    public function subtotal(): Money {
        return $this->unitPrice->multiply($this->quantity->value());
    }
}
```

---

## 4.6 قياس جودة التجريد

### المقاييس

#### 1. Coupling (الترابط)

**Afferent Coupling (Ca):**
عدد الكلاسات التي تعتمد على هذه الكلاس.

**Efferent Coupling (Ce):**
عدد الكلاسات التي تعتمد عليها هذه الكلاس.

**Instability:**
```
I = Ce / (Ce + Ca)
```
- I = 0: مستقر جداً (مثل Domain)
- I = 1: غير مستقر (مثل Controller)

#### 2. Abstraction

**Abstractness:**
```
A = عدد الكلاسات والإنترفيسات المجردة / العدد الكلي
```

**التوازن المثالي:**
الم-packages يجب أن تكون:
- Domain: A عالي (مجرد), I منخفض (مستقر)
- Application: A متوسط, I متوسط
- Infrastructure: A منخفض (concrete), I عالٍ (غير مستقر)

#### 3. Distance from Main Sequence

**المعادلة:**
```
D = |A + I - 1|
```

**التفسير:**
- D = 0: مثالي
- D قريب من 0: جيد
- D بعيد عن 0: يحتاج مراجعة

### أدوات القياس

**PHP:**
```bash
# PHP Depend
vendor/bin/pdepend --jdepend-xml=report.xml src/

# PHP Metrics
vendor/bin/phpmetrics --report-html=metrics.html src/

# Deptrac
vendor/bin/deptrac analyse
```

---

## خاتمة الفصل الرابع

### ما تعلمناه

**المستويات:**
- 7 مستويات للتجريد المعماري
- كل مستوى يخدم غرضاً محدداً
- الالتزام بـ Dependency Rule

**الأنماط:**
- 6 أنماط رئيسية للتجريد
- كل نمط له استخدامه الأمثل
- التوافق مع مبادئ SOLID

**التطبيق:**
- أمثلة برمجية واقعية
- دراسة حالة لـ Legacy refactoring
- أفضل الممارسات في PHP

### الخطوط العريضة

**1. ابدأ من Domain**
النواة هي الأهم. اجعلها نقية ومجردة.

**2. استخدم Patterns بحكمة**
لا تفرط، ولا تبخل. اختر ما يناسب.

**3. قس وتحسن**
استخدم الأدوات لقياس الجودة. تحسن باستمرار.

### إلى الفصل الخامس

في **"السيادة الزمنية"**، سنستكشف:
- الـ Time كبعد معماري
- الـ Event Sourcing بعمق
- التعامل مع Consistency
- أنماط الـ Temporal

---

**© 2025 محمد العبيد | المعماري**

*"السيادة الحقيقية على حرفتك"*

**نهاية الفصل الرابع - فن التجريد**

