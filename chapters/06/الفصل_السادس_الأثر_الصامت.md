# Ø§Ù„ÙØµÙ„ Ø§Ù„Ø³Ø§Ø¯Ø³: Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

## Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© ÙÙŠ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©

---

## Ù…Ù‚Ø¯Ù…Ø©: Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…ØªØŸ

> "ÙƒÙ„ Ù†Ø¸Ø§Ù… Ø¨Ø±Ù…Ø¬ÙŠ ÙŠØ¹ÙŠØ´ ÙÙŠ Ø¹Ø§Ù„Ù… Ø£ÙƒØ¨Ø± Ù…Ù†Ù‡. Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© - Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØŒ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§ØªØŒ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª - Ù‡ÙŠ Ø§Ù„Ø¬Ø³Ø± Ø¨ÙŠÙ† Ø¹Ø§Ù„Ù…Ùƒ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ ÙˆØ§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ."

Ø¹Ù†Ø¯Ù…Ø§ Ù†ØªØ­Ø¯Ø« Ø¹Ù† Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ©ØŒ Ù†Ø±ÙƒØ² ØºØ§Ù„Ø¨Ø§Ù‹ Ø¹Ù„Ù‰ **Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©**: Domain ModelsØŒ ÙˆØ§Ù„Ù€ AggregatesØŒ Ùˆ Ø§Ù„Ù€ Services. Ù„ÙƒÙ† Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø© Ù‡ÙŠ Ø£Ù† Ù…Ø¹Ø¸Ù… Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ù„Ø§ ØªØ¹ÙŠØ´ ÙÙŠ Ø¹Ø²Ù„Ø©. Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ - Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØŒ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¯ÙØ¹ØŒ Ø¯ÙØ¹ Ø¥Ø´Ø¹Ø§Ø±ØŒ ÙƒØªØ§Ø¨Ø© Ù„Ù…Ù„Ù - ÙƒÙ„Ù‡Ø§ **ØªØ£Ø«ÙŠØ±Ø§Øª Ø®Ø§Ø±Ø¬ÙŠØ©** (Side Effects) Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¬Ù†Ø¨Ù‡Ø§.

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©

**Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª Ù‡Ùˆ:**
- ØªØºÙŠÙŠØ± ÙÙŠ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù…
- Ø¹Ù…Ù„ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡ Ø¨Ø³Ù‡ÙˆÙ„Ø©
- ØªØ¨Ø¹ÙŠØ© Ø¹Ù„Ù‰ Ù…ÙˆØ§Ø±Ø¯ Ø®Ø§Ø±Ø¬ÙŠØ©

**Ù„Ù…Ø§Ø°Ø§ Ù‡Ùˆ "ØµØ§Ù…Øª"ØŸ**
Ù„Ø£Ù†Ù‡ ØºØ§Ù„Ø¨Ø§Ù‹ Ù…Ø§ ÙŠØ®ØªÙÙŠ ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©ØŒ Ù„Ø§ ÙŠØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ù€ APIØŒ Ù„Ø§ ÙŠÙØ®ØªØ¨Ø± Ø¨Ø´ÙƒÙ„ ÙƒØ§ÙÙØŒ ÙˆÙŠØ³Ø¨Ø¨ Ù…Ø´Ø§ÙƒÙ„ ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬.

### Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ðŸŒ External APIs                                          â”‚
â”‚     - Payment Gateways                                     â”‚
â”‚     - Shipping Services                                    â”‚
â”‚     - Third-party Integrations                             â”‚
â”‚                                                             â”‚
â”‚  ðŸ“§ Notifications                                          â”‚
â”‚     - Email                                                â”‚
â”‚     - SMS                                                  â”‚
â”‚     - Push Notifications                                   â”‚
â”‚                                                             â”‚
â”‚  ðŸ’¾ File Operations                                        â”‚
â”‚     - File Upload/Download                                 â”‚
â”‚     - Report Generation                                    â”‚
â”‚     - Image Processing                                     â”‚
â”‚                                                             â”‚
â”‚  ðŸ” Search Indexing                                        â”‚
â”‚     - Elasticsearch                                        â”‚
â”‚     - Algolia                                              â”‚
â”‚     - Full-text Search                                     â”‚
â”‚                                                             â”‚
â”‚  ðŸ“Š Analytics & Logging                                    â”‚
â”‚     - Event Tracking                                       â”‚
â”‚     - Audit Logs                                           â”‚
â”‚     - Metrics Collection                                   â”‚
â”‚                                                             â”‚
â”‚  ðŸ—„ï¸ Data Replication                                       â”‚
â”‚     - Read Models (CQRS)                                   â”‚
â”‚     - Cache Updates                                        â”‚
â”‚     - Data Warehouses                                      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6.1 Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª ÙÙŠ Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ©

### ØªØ¹Ø±ÙŠÙ Ø¯Ù‚ÙŠÙ‚

**Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª (Side Effect):**
Ù‡Ùˆ Ø£ÙŠ ØªØºÙŠÙŠØ± ÙÙŠ Ø§Ù„Ø­Ø§Ù„Ø© Ø®Ø§Ø±Ø¬ Ø§Ù„Ù€ Aggregate Root Ø£Ùˆ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ Ù„Ù„Ù†Ø¸Ø§Ù…ØŒ ÙŠØ­Ø¯Ø« Ù†ØªÙŠØ¬Ø© Ù„Ø¹Ù…Ù„ÙŠØ© domain.

**Ù…Ø«Ø§Ù„ ÙˆØ§Ø¶Ø­:**
```php
// Ù‡Ø°Ø§ Ù„ÙŠØ³ side effect - ØªØºÙŠÙŠØ± Ø¯Ø§Ø®Ù„ÙŠ
class Order {
    public function confirm(): void {
        $this->status = OrderStatus::CONFIRMED; // âœ… ØªØºÙŠÙŠØ± Ø¯Ø§Ø®Ù„ÙŠ
    }
}

// Ù‡Ø°Ø§ side effect - ØªÙØ§Ø¹Ù„ Ø®Ø§Ø±Ø¬ÙŠ
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        
        // âŒ Side Effect: Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
        $this->emailService->send(
            $order->customerEmail(),
            'Order Confirmed',
            'Your order has been confirmed!'
        );
        
        // âŒ Side Effect: ØªØ­Ø¯ÙŠØ« index
        $this->searchIndex->update($order);
        
        // âŒ Side Effect: Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±
        $this->notificationService->push($order->customerId(), 'Order confirmed');
    }
}
```

### Ù„Ù…Ø§Ø°Ø§ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª Ù…Ø´ÙƒÙ„Ø©ØŸ

#### 1. Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
```php
// ÙƒÙŠÙ Ù†Ø®ØªØ¨Ø± Ù‡Ø°Ø§ØŸ
class OrderServiceTest {
    public function testConfirmOrderSendsEmail(): void {
        $service = new OrderService(
            $this->repository,
            new RealEmailService(),  // âŒ Ø³ÙŠØ±Ø³Ù„ Ø¨Ø±ÙŠØ¯ Ø­Ù‚ÙŠÙ‚ÙŠ!
            $this->searchIndex,
            $this->notificationService
        );
        
        $service->confirmOrder($this->orderId);
        
        // ÙƒÙŠÙ Ù†ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø£ÙØ±Ø³Ù„ØŸ
        // ÙƒÙŠÙ Ù†ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø£Ø®Ø·Ø§Ø¡ØŸ
    }
}
```

**Ø§Ù„Ø­Ù„:**
Ø¹Ø²Ù„ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª ÙÙŠ abstractions.

#### 2. Ø§Ù„ØªØ±Ø§Ø¬Ø¹ (Rollback)

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
```php
// ÙÙŠ Saga
class OrderProcessingSaga {
    public function execute(): void {
        try {
            $this->payment->charge();      // âœ… ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹: refund
            $this->inventory->reserve();   // âœ… ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹: release
            $this->email->send();          // âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹!
        } catch (Exception $e) {
            $this->compensate();  // Ù„ÙƒÙ† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø£ÙØ±Ø³Ù„ Ø¨Ø§Ù„ÙØ¹Ù„
        }
    }
}
```

**Ø§Ù„Ø­Ù„:**
ØªØ£Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª Ø­ØªÙ‰ Ù†ØªØ£ÙƒØ¯ Ù…Ù† Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.

#### 3. Consistency

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
```php
// Ù…Ø§ Ù‡Ùˆ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ØµØ­ÙŠØ­ Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ØŸ
class OrderService {
    public function confirmOrder(OrderId $id): void {
        // Ù‚Ø¨Ù„ Ø­ÙØ¸ Ø§Ù„Ø·Ù„Ø¨ØŸ
        $this->emailService->sendConfirmation($order);  // âŒ Ù…Ø§Ø°Ø§ Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸ØŸ
        
        $this->repository->save($order);
        
        // Ø¨Ø¹Ø¯ Ø§Ù„Ø­ÙØ¸ØŸ
        $this->emailService->sendConfirmation($order);  // âŒ Ù…Ø§Ø°Ø§ Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ØŸ
    }
}
```

**Ø§Ù„Ø­Ù„:**
 eventual consistency Ù…Ø¹ outbox pattern.

### Ù…Ø¨Ø§Ø¯Ø¦ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

#### Ø§Ù„Ù…Ø¨Ø¯Ø£ 1: Ø¹Ø²Ù„ (Isolation)
```php
// âŒ Ø³ÙŠØ¡: Ø§Ø®ØªÙ„Ø§Ø· Ø§Ù„Ù…Ù†Ø·Ù‚
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        $this->repository->save($order);
        
        // Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ù…Ø®ØªÙ„Ø· Ù…Ø¹ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø·Ù„Ø¨
        $smtp = new SMTPClient();
        $smtp->connect('smtp.gmail.com');
        $smtp->send([
            'to' => $order->customerEmail(),
            'subject' => 'Order Confirmed',
            'body' => $this->buildEmailBody($order)
        ]);
    }
}

// âœ… Ø¬ÙŠØ¯: Ø¹Ø²Ù„ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª
interface NotificationService {
    public function notifyOrderConfirmed(Order $order): void;
}

class OrderService {
    public function __construct(
        private OrderRepository $repository,
        private NotificationService $notificationService  // Abstraction
    ) {}
    
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        $this->repository->save($order);
        
        // Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª Ù…Ø¹Ø²ÙˆÙ„
        $this->notificationService->notifyOrderConfirmed($order);
    }
}
```

#### Ø§Ù„Ù…Ø¨Ø¯Ø£ 2: ØªØ£Ø¬ÙŠÙ„ (Deferral)
```php
// âŒ Ø³ÙŠØ¡: ÙÙˆØ±ÙŠ ÙˆÙ…Ø²Ø§Ù…Ù†
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        
        // ÙŠØ­Ø¸Ø± Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø­ØªÙ‰ ÙŠÙØ±Ø³Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯
        $this->emailService->sendConfirmation($order);  // Ø¨Ø·ÙŠØ¡!
        
        $this->repository->save($order);
    }
}

// âœ… Ø¬ÙŠØ¯: ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        $this->repository->save($order);
        
        // Ù†Ø´Ø± Ø­Ø¯Ø« - Ø§Ù„Ø¨Ø±ÙŠØ¯ ÙŠÙØ±Ø³Ù„ Ù„Ø§Ø­Ù‚Ø§Ù‹
        $this->eventBus->publish(new OrderConfirmed($order->id()));
    }
}

// Event Handler ÙŠØ±Ø³Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯
class OrderConfirmedEmailHandler {
    public function onOrderConfirmed(OrderConfirmed $event): void {
        $order = $this->repository->find($event->orderId());
        $this->emailService->sendConfirmation($order);
    }
}
```

#### Ø§Ù„Ù…Ø¨Ø¯Ø£ 3: Ù‚Ø§Ø¨Ù„ÙŠØ© Ø§Ù„ØªÙƒØ±Ø§Ø± (Idempotency)
```php
// âŒ Ø³ÙŠØ¡: ØºÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªÙƒØ±Ø§Ø±
class EmailService {
    public function sendConfirmation(Order $order): void {
        $this->smtp->send([
            'to' => $order->customerEmail(),
            'subject' => 'Order Confirmed',
            'body' => '...'
        ]);
        // Ø¥Ø°Ø§ Ø§Ø³ØªÙØ¯Ø¹ÙŠ Ù…Ø±ØªÙŠÙ† â†’ ÙŠÙØ±Ø³Ù„ Ø¨Ø±ÙŠØ¯ÙŠÙ†!
    }
}

// âœ… Ø¬ÙŠØ¯: Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªÙƒØ±Ø§Ø±
class EmailService {
    public function sendConfirmation(Order $order): void {
        $emailId = "order_confirmation:{$order->id()}:{$order->version()}";
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ Ø£ÙØ±Ø³Ù„ Ø¨Ø§Ù„ÙØ¹Ù„
        if ($this->sentEmails->has($emailId)) {
            return;  // Ù„Ø§ Ø´ÙŠØ¡ ÙŠØ­Ø¯Ø«
        }
        
        $this->smtp->send([
            'message_id' => $emailId,  // Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯
            'to' => $order->customerEmail(),
            'subject' => 'Order Confirmed',
            'body' => '...'
        ]);
        
        $this->sentEmails->markAsSent($emailId);
    }
}
```

---

## 6.2 Ø£Ù†Ù…Ø§Ø· Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

### Ø§Ù„Ù†Ù…Ø· 1: Outbox Pattern

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
ÙƒÙŠÙ Ù†Ø¶Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª Ø¥Ø°Ø§ Ù†Ø¬Ø­Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©ØŸ

**Ø§Ù„Ø­Ù„:**
Outbox Pattern - Ø­ÙØ¸ Ø§Ù„Ø£Ø«Ø± ÙÙŠ Ù†ÙØ³ transaction Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.

```php
// âŒ Ù…Ø´ÙƒÙ„Ø©: Dual Write
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $this->db->transaction(function() {
            $order = $this->repository->find($id);
            $order->confirm();
            $this->repository->save($order);
        });  // âœ… Transaction ÙŠÙ†Ø¬Ø­
        
        // âŒ Ù„ÙƒÙ† Ù…Ø§Ø°Ø§ Ø¥Ø°Ø§ ÙØ´Ù„ Ù‡Ø°Ø§ØŸ
        $this->emailService->sendConfirmation($order);
    }
}

// âœ… Ø§Ù„Ø­Ù„: Outbox Pattern
class OutboxMessage {
    public function __construct(
        public readonly string $id,
        public readonly string $type,
        public readonly array $payload,
        public readonly ?DateTimeImmutable $processedAt = null
    ) {}
}

class OrderService {
    private OutboxRepository $outbox;
    
    public function confirmOrder(OrderId $id): void {
        $this->db->transaction(function() use ($id) {
            $order = $this->repository->find($id);
            $order->confirm();
            $this->repository->save($order);
            
            // Ø­ÙØ¸ ÙÙŠ Outbox - Ù†ÙØ³ transaction!
            $this->outbox->save(new OutboxMessage(
                id: Uuid::generate(),
                type: 'send_order_confirmation_email',
                payload: [
                    'order_id' => $order->id()->toString(),
                    'customer_email' => $order->customerEmail(),
                    'customer_name' => $order->customerName(),
                ]
            ));
        });  // âœ… ÙƒÙ„Ø§Ù‡Ù…Ø§ atomic
    }
}

// Processor Ù…Ù†ÙØµÙ„ ÙŠØ¹Ø§Ù„Ø¬ Outbox
class OutboxProcessor {
    public function process(): void {
        $messages = $this->outbox->findUnprocessed(100);
        
        foreach ($messages as $message) {
            try {
                $this->dispatch($message);
                $this->outbox->markAsProcessed($message->id);
            } catch (Exception $e) {
                $this->outbox->markAsFailed($message->id, $e);
                // Ø³ÙŠØ¹ÙŠØ¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹
            }
        }
    }
    
    private function dispatch(OutboxMessage $message): void {
        match ($message->type) {
            'send_order_confirmation_email' => $this->sendEmail($message->payload),
            'update_search_index' => $this->updateIndex($message->payload),
            'notify_shipping_service' => $this->notifyShipping($message->payload),
            default => throw new UnknownMessageTypeException($message->type)
        };
    }
}
```

**Ø§Ù„ÙØ§Ø¦Ø¯Ø©:**
- Atomicity: Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ø£Ø«Ø± ÙŠÙØ­ÙØ¸Ø§Ù† Ù…Ø¹Ø§Ù‹
- Reliability: Ù„Ù† Ù†ÙÙ‚Ø¯ Ø§Ù„Ø£Ø«Ø±
- Ordering: Ø§Ù„Ø£Ø«Ø± ÙŠÙØ±Ø³Ù„ Ø¨ØªØ±ØªÙŠØ¨ Ø§Ù„Ø­ÙØ¸
- Retries: Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø°Ø§ ÙØ´Ù„

### Ø§Ù„Ù†Ù…Ø· 2: Event-Driven Side Effects

**Ø§Ù„Ù…ÙÙ‡ÙˆÙ…:**
Ù†Ø´Ø± Ø£Ø­Ø¯Ø§Ø« DomainØŒ ÙˆØ§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª ÙŠØ³ØªÙ…Ø¹ ÙˆÙŠØªÙØ§Ø¹Ù„.

```php
// Domain Event
class OrderConfirmed implements DomainEvent {
    public function __construct(
        public readonly OrderId $orderId,
        public readonly CustomerId $customerId,
        public readonly Money $total,
        public readonly DateTimeImmutable $occurredAt
    ) {}
}

// Aggregate ÙŠÙ†Ø´Ø± Ø§Ù„Ø­Ø¯Ø«
class Order {
    public function confirm(): void {
        // ... Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ£ÙƒÙŠØ¯
        
        $this->recordEvent(new OrderConfirmed(
            orderId: $this->id,
            customerId: $this->customerId,
            total: $this->total(),
            occurredAt: new DateTimeImmutable()
        ));
    }
}

// Handlers Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª
class OrderConfirmedEmailHandler {
    public function onOrderConfirmed(OrderConfirmed $event): void {
        $order = $this->repository->find($event->orderId);
        
        $this->emailService->sendTemplated('order_confirmed', [
            'to' => $order->customerEmail(),
            'order_number' => $order->orderNumber(),
            'total' => $order->total()->format(),
            'items' => $order->items(),
        ]);
    }
}

class OrderConfirmedNotificationHandler {
    public function onOrderConfirmed(OrderConfirmed $event): void {
        $this->pushNotification->send(
            userId: $event->customerId,
            title: 'Order Confirmed!',
            body: "Your order #{$event->orderId} has been confirmed."
        );
    }
}

class OrderConfirmedAnalyticsHandler {
    public function onOrderConfirmed(OrderConfirmed $event): void {
        $this->analytics->track('order_confirmed', [
            'order_id' => $event->orderId->toString(),
            'value' => $event->total->amount(),
            'currency' => $event->total->currency()->code(),
        ]);
    }
}

class OrderConfirmedSearchIndexHandler {
    public function onOrderConfirmed(OrderConfirmed $event): void {
        $order = $this->repository->find($event->orderId);
        
        $this->searchIndex->index([
            'id' => $order->id()->toString(),
            'status' => 'confirmed',
            'customer_id' => $order->customerId()->toString(),
            'total' => $order->total()->amount(),
            'confirmed_at' => $event->occurredAt->format('c'),
        ]);
    }
}
```

**Ø§Ù„ÙØ§Ø¦Ø¯Ø©:**
- ÙØµÙ„ ÙˆØ§Ø¶Ø­ Ø¨ÙŠÙ† Domain ÙˆØ§Ù„Ù€ Infrastructure
- Ø¥Ø¶Ø§ÙØ© Ø£Ø«Ø± ØµØ§Ù…Øª Ø¬Ø¯ÙŠØ¯ Ø¨Ø¯ÙˆÙ† ØªØ¹Ø¯ÙŠÙ„ Domain
- ÙƒÙ„ handler Ù…Ø³Ø¤ÙˆÙ„ Ø¹Ù† side effect ÙˆØ§Ø­Ø¯
- Ø³Ù‡Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ø´ÙƒÙ„ Ù…Ù†ÙØµÙ„

### Ø§Ù„Ù†Ù…Ø· 3: Saga with Compensation

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
Ù…Ø§Ø°Ø§ Ù„Ùˆ ÙØ´Ù„ Ø£Ø­Ø¯ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª ÙÙŠ Ù…Ù†ØªØµÙ SagaØŸ

**Ø§Ù„Ø­Ù„:**
Compensation - ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª.

```php
interface CompensatableAction {
    public function execute(): mixed;
    public function compensate(mixed $context): void;
}

class SendEmailAction implements CompensatableAction {
    public function __construct(
        private EmailService $emailService,
        private string $to,
        private string $subject,
        private string $body
    ) {}
    
    public function execute(): mixed {
        $messageId = $this->emailService->send([
            'to' => $this->to,
            'subject' => $this->subject,
            'body' => $this->body,
        ]);
        
        return $messageId;  // Context Ù„Ù„Ù€ compensation
    }
    
    public function compensate(mixed $context): void {
        // ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ù„Ø§ ÙŠÙ…ÙƒÙ† "Ø¥Ù„ØºØ§Ø¤Ù‡"
        // Ù„ÙƒÙ† ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ ØªØµØ­ÙŠØ­
        $messageId = $context;
        
        $this->emailService->send([
            'to' => $this->to,
            'subject' => 'Correction: ' . $this->subject,
            'body' => 'Please disregard the previous email. An error occurred.',
        ]);
    }
}

class Saga {
    private array $completedSteps = [];
    private array $contexts = [];
    
    public function execute(array $actions): void {
        try {
            foreach ($actions as $index => $action) {
                $context = $action->execute();
                
                $this->completedSteps[] = $action;
                $this->contexts[] = $context;
            }
        } catch (Exception $e) {
            // Compensation: Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
            $this->compensate();
            throw $e;
        }
    }
    
    private function compensate(): void {
        // Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¨Ø¹ÙƒØ³ Ø§Ù„ØªØ±ØªÙŠØ¨
        for ($i = count($this->completedSteps) - 1; $i >= 0; $i--) {
            $this->completedSteps[$i]->compensate($this->contexts[$i]);
        }
    }
}
```

### Ø§Ù„Ù†Ù…Ø· 4: Circuit Breaker Ù„Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
Ù…Ø§Ø°Ø§ Ù„Ùˆ Service Ø®Ø§Ø±Ø¬ÙŠ (Ù…Ø«Ù„ Email) Ù„Ø§ ÙŠØ³ØªØ¬ÙŠØ¨ØŸ

**Ø§Ù„Ø­Ù„:**
Circuit Breaker - Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù„ÙØªØ±Ø©.

```php
class CircuitBreaker {
    private int $failureCount = 0;
    private int $successCount = 0;
    private ?DateTimeImmutable $lastFailureTime = null;
    private string $state = 'CLOSED';  // CLOSED, OPEN, HALF_OPEN
    
    public function __construct(
        private int $failureThreshold = 5,
        private int $timeout = 60  // seconds
    ) {}
    
    public function call(callable $operation) {
        if ($this->state === 'OPEN') {
            if ($this->shouldRetry()) {
                $this->state = 'HALF_OPEN';
            } else {
                throw new CircuitOpenException('Service unavailable');
            }
        }
        
        try {
            $result = $operation();
            $this->onSuccess();
            return $result;
        } catch (Exception $e) {
            $this->onFailure();
            throw $e;
        }
    }
    
    private function onSuccess(): void {
        $this->successCount++;
        $this->failureCount = 0;
        $this->state = 'CLOSED';
    }
    
    private function onFailure(): void {
        $this->failureCount++;
        $this->lastFailureTime = new DateTimeImmutable();
        
        if ($this->failureCount >= $this->failureThreshold) {
            $this->state = 'OPEN';
        }
    }
    
    private function shouldRetry(): bool {
        if (!$this->lastFailureTime) {
            return true;
        }
        
        $elapsed = time() - $this->lastFailureTime->getTimestamp();
        return $elapsed > $this->timeout;
    }
}

// Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
class EmailServiceWithCircuitBreaker {
    private CircuitBreaker $circuitBreaker;
    private OutboxRepository $outbox;
    
    public function sendWithProtection(array $email): void {
        try {
            $this->circuitBreaker->call(function() use ($email) {
                return $this->smtp->send($email);
            });
        } catch (CircuitOpenException $e) {
            // Ø­ÙØ¸ ÙÙŠ Outbox Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹
            $this->outbox->save(new OutboxMessage(
                type: 'email',
                payload: $email
            ));
        }
    }
}
```

---

*ÙŠØªØ¨Ø¹...*


## 6.3 ØªØ·Ø¨ÙŠÙ‚ Ø¹Ù…Ù„ÙŠ: Ù†Ø¸Ø§Ù… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…ØªÙƒØ§Ù…Ù„

### Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª

**Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ­ØªØ§Ø¬ Ù„Ø¥Ø±Ø³Ø§Ù„:**
- Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ (Transactional)
- SMS
- Push Notifications (Mobile)
- In-App Notifications
- Webhook Ù„Ù„Ù€ integrators

**Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª:**
1. Reliability: Ø¹Ø¯Ù… ÙÙ‚Ø¯Ø§Ù† Ø£ÙŠ Ø¥Ø´Ø¹Ø§Ø±
2. Ordering: Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØ±ØªÙŠØ¨
3. Idempotency: Ø¹Ø¯Ù… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙƒØ±Ø±
4. Performance: Ø¹Ø¯Ù… ØªØ£Ø«ÙŠØ± Ø£Ø¯Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
5. Observability: ØªØªØ¨Ø¹ ÙˆÙ…Ø±Ø§Ù‚Ø¨Ø©

### Ø§Ù„Ø¨Ù†ÙŠØ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application                              â”‚
â”‚                   (Domain Events)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Event Bus    â”‚
                â”‚   (Kafka)      â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚   Email      â”‚ â”‚    SMS      â”‚ â”‚    Push     â”‚
â”‚   Service    â”‚ â”‚   Service   â”‚ â”‚   Service   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â”‚               â”‚               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚   SendGrid   â”‚ â”‚   Twilio    â”‚ â”‚   Firebase  â”‚
â”‚   / SES      â”‚ â”‚             â”‚ â”‚   / OneSignalâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ø§Ù„ØªÙ†ÙÙŠØ°

#### 1. Notification Domain Model

```php
// Notification ÙƒÙ€ Entity
class Notification {
    private NotificationId $id;
    private RecipientId $recipientId;
    private string $type;  // 'email', 'sms', 'push'
    private NotificationContent $content;
    private NotificationStatus $status;
    private ?DateTimeImmutable $sentAt = null;
    private ?DateTimeImmutable $deliveredAt = null;
    private ?string $error = null;
    private int $retryCount = 0;
    
    public static function create(
        RecipientId $recipientId,
        string $type,
        NotificationContent $content
    ): self {
        $notification = new self();
        $notification->record(new NotificationCreated(
            id: NotificationId::generate(),
            recipientId: $recipientId,
            type: $type,
            content: $content,
            createdAt: new DateTimeImmutable()
        ));
        return $notification;
    }
    
    public function markAsSent(string $providerMessageId): void {
        $this->record(new NotificationSent(
            notificationId: $this->id,
            providerMessageId: $providerMessageId,
            sentAt: new DateTimeImmutable()
        ));
    }
    
    public function markAsDelivered(): void {
        $this->record(new NotificationDelivered(
            notificationId: $this->id,
            deliveredAt: new DateTimeImmutable()
        ));
    }
    
    public function markAsFailed(string $error): void {
        $this->record(new NotificationFailed(
            notificationId: $this->id,
            error: $error,
            failedAt: new DateTimeImmutable()
        ));
    }
    
    public function scheduleRetry(): void {
        if ($this->retryCount >= 3) {
            $this->record(new NotificationMaxRetriesReached(
                notificationId: $this->id
            ));
            return;
        }
        
        $this->record(new NotificationRetryScheduled(
            notificationId: $this->id,
            retryCount: ++$this->retryCount,
            retryAt: $this->calculateRetryTime()
        ));
    }
    
    private function calculateRetryTime(): DateTimeImmutable {
        // Exponential backoff
        $delays = [60, 300, 900];  // 1min, 5min, 15min
        $delay = $delays[$this->retryCount - 1] ?? 3600;
        
        return (new DateTimeImmutable())->modify("+{$delay} seconds");
    }
}

// Value Objects
class NotificationContent {
    public function __construct(
        public readonly string $subject,
        public readonly string $body,
        public readonly ?string $template = null,
        public readonly array $variables = []
    ) {}
    
    public function render(TemplateEngine $engine): string {
        if ($this->template) {
            return $engine->render($this->template, $this->variables);
        }
        return $this->body;
    }
}

enum NotificationStatus: string {
    case PENDING = 'pending';
    case SENT = 'sent';
    case DELIVERED = 'delivered';
    case FAILED = 'failed';
    case RETRY_SCHEDULED = 'retry_scheduled';
    case MAX_RETRIES_REACHED = 'max_retries_reached';
}
```

#### 2. Notification Providers (Strategy Pattern)

```php
interface NotificationProvider {
    public function send(Notification $notification): ProviderResult;
    public function supports(string $type): bool;
}

// Email Provider
class SendGridProvider implements NotificationProvider {
    public function __construct(
        private SendGridClient $client,
        private LoggerInterface $logger
    ) {}
    
    public function send(Notification $notification): ProviderResult {
        try {
            $recipient = $this->getRecipientEmail($notification->recipientId());
            
            $response = $this->client->send([
                'personalizations' => [
                    ['to' => [['email' => $recipient]]]
                ],
                'from' => ['email' => 'noreply@example.com'],
                'subject' => $notification->content()->subject,
                'content' => [
                    ['type' => 'text/html', 'value' => $notification->content()->body]
                ]
            ]);
            
            $this->logger->info('Email sent via SendGrid', [
                'notification_id' => $notification->id()->toString(),
                'sendgrid_message_id' => $response->messageId()
            ]);
            
            return ProviderResult::success($response->messageId());
            
        } catch (SendGridException $e) {
            $this->logger->error('SendGrid failed', [
                'notification_id' => $notification->id()->toString(),
                'error' => $e->getMessage()
            ]);
            
            return ProviderResult::failure($e->getMessage(), $e->isRetryable());
        }
    }
    
    public function supports(string $type): bool {
        return $type === 'email';
    }
}

// SMS Provider
class TwilioProvider implements NotificationProvider {
    public function __construct(
        private TwilioClient $client
    ) {}
    
    public function send(Notification $notification): ProviderResult {
        $recipient = $this->getRecipientPhone($notification->recipientId());
        
        $message = $this->client->messages->create(
            $recipient,
            [
                'from' => config('twilio.phone_number'),
                'body' => $notification->content()->body
            ]
        );
        
        return ProviderResult::success($message->sid);
    }
    
    public function supports(string $type): bool {
        return $type === 'sms';
    }
}

// Push Notification Provider
class FirebaseProvider implements NotificationProvider {
    public function __construct(
        private Messaging $messaging
    ) {}
    
    public function send(Notification $notification): ProviderResult {
        $deviceToken = $this->getDeviceToken($notification->recipientId());
        
        $message = CloudMessage::withTarget('token', $deviceToken)
            ->withNotification([
                'title' => $notification->content()->subject,
                'body' => $notification->content()->body,
            ])
            ->withData([
                'notification_id' => $notification->id()->toString(),
            ]);
        
        $this->messaging->send($message);
        
        return ProviderResult::success('firebase_message_id');
    }
    
    public function supports(string $type): bool {
        return $type === 'push';
    }
}

// Provider Factory
class NotificationProviderFactory {
    private array $providers = [];
    
    public function register(string $type, NotificationProvider $provider): void {
        $this->providers[$type] = $provider;
    }
    
    public function getFor(string $type): NotificationProvider {
        if (!isset($this->providers[$type])) {
            throw new UnsupportedNotificationTypeException($type);
        }
        
        return $this->providers[$type];
    }
}
```

#### 3. Notification Service

```php
class NotificationService {
    public function __construct(
        private NotificationRepository $notifications,
        private NotificationProviderFactory $providers,
        private EventBus $eventBus,
        private OutboxRepository $outbox,
        private CircuitBreaker $circuitBreaker
    ) {}
    
    public function send(
        RecipientId $recipientId,
        string $type,
        NotificationContent $content
    ): NotificationId {
        // Ø¥Ù†Ø´Ø§Ø¡ Notification
        $notification = Notification::create($recipientId, $type, $content);
        
        // Ø­ÙØ¸ ÙÙŠ Ù†ÙØ³ transaction Ù…Ø¹ Outbox
        $this->db->transaction(function() use ($notification) {
            $this->notifications->save($notification);
            
            $this->outbox->save(new OutboxMessage(
                type: 'send_notification',
                payload: [
                    'notification_id' => $notification->id()->toString(),
                ]
            ));
        });
        
        return $notification->id();
    }
    
    public function processPending(): void {
        $pending = $this->outbox->findUnprocessed(100);
        
        foreach ($pending as $message) {
            try {
                $this->processNotification($message);
                $this->outbox->markAsProcessed($message->id());
            } catch (Exception $e) {
                $this->outbox->markAsFailed($message->id, $e);
            }
        }
    }
    
    private function processNotification(OutboxMessage $message): void {
        $notification = $this->notifications->find(
            NotificationId::fromString($message->payload['notification_id'])
        );
        
        if (!$notification) {
            return;
        }
        
        // Circuit Breaker Ù„Ù„Ø­Ù…Ø§ÙŠØ©
        $result = $this->circuitBreaker->call(function() use ($notification) {
            $provider = $this->providers->getFor($notification->type());
            return $provider->send($notification);
        });
        
        if ($result->isSuccess()) {
            $notification->markAsSent($result->providerMessageId());
            $this->notifications->save($notification);
            
            // Ù†Ø´Ø± Ø­Ø¯Ø« Ù„Ù„Ù€ delivery tracking
            $this->eventBus->publish(new NotificationSent(
                notificationId: $notification->id(),
                providerMessageId: $result->providerMessageId()
            ));
        } else {
            $notification->markAsFailed($result->error());
            
            if ($result->isRetryable()) {
                $notification->scheduleRetry();
            }
            
            $this->notifications->save($notification);
        }
    }
}
```

#### 4. Delivery Tracking

```php
class DeliveryTrackingService {
    public function __construct(
        private NotificationRepository $notifications,
        private WebhookDispatcher $webhooks
    ) {}
    
    // Ø§Ø³ØªØ¯Ø¹Ù‰ Ù…Ù† webhook (SendGrid, Twilio, etc.)
    public function handleDeliveryWebhook(string $provider, array $payload): void {
        $providerMessageId = $payload['message_id'] ?? $payload['sid'] ?? null;
        $status = $payload['event'] ?? $payload['status'] ?? null;
        
        if (!$providerMessageId) {
            return;
        }
        
        $notification = $this->notifications->findByProviderMessageId($providerMessageId);
        
        if (!$notification) {
            return;
        }
        
        match ($status) {
            'delivered', 'delivery' => $this->handleDelivered($notification),
            'bounce', 'undelivered' => $this->handleFailed($notification, $payload),
            'open', 'click' => $this->handleEngagement($notification, $status),
            default => null
        };
    }
    
    private function handleDelivered(Notification $notification): void {
        $notification->markAsDelivered();
        $this->notifications->save($notification);
        
        // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
        $this->webhooks->dispatch('notification.delivered', [
            'notification_id' => $notification->id()->toString(),
            'delivered_at' => (new DateTimeImmutable())->format('c'),
        ]);
    }
    
    private function handleFailed(Notification $notification, array $payload): void {
        $error = $payload['reason'] ?? 'Unknown error';
        $notification->markAsFailed($error);
        $this->notifications->save($notification);
    }
}
```

### Monitoring

```php
// Metrics
class NotificationMetrics {
    public function recordSent(string $type, float $latency): void {
        Metrics::histogram('notifications_sent_total', 1, ['type' => $type]);
        Metrics::histogram('notification_latency_seconds', $latency, ['type' => $type]);
    }
    
    public function recordFailed(string $type, string $reason): void {
        Metrics::counter('notifications_failed_total', 1, [
            'type' => $type,
            'reason' => $reason
        ]);
    }
    
    public function recordDelivered(string $type): void {
        Metrics::counter('notifications_delivered_total', 1, ['type' => $type]);
    }
}

// Dashboard queries
class NotificationDashboard {
    public function getStats(DateRange $range): array {
        return [
            'sent' => $this->db->fetchOne(
                'SELECT COUNT(*) FROM notifications 
                 WHERE created_at BETWEEN ? AND ?',
                [$range->start(), $range->end()]
            ),
            'delivered' => $this->db->fetchOne(
                'SELECT COUNT(*) FROM notifications 
                 WHERE status = ? AND delivered_at BETWEEN ? AND ?',
                ['delivered', $range->start(), $range->end()]
            ),
            'failed' => $this->db->fetchOne(
                'SELECT COUNT(*) FROM notifications 
                 WHERE status = ? AND created_at BETWEEN ? AND ?',
                ['failed', $range->start(), $range->end()]
            ),
            'delivery_rate' => $this->calculateDeliveryRate($range),
            'average_latency' => $this->calculateAverageLatency($range),
        ];
    }
}
```

---

*ÙŠØªØ¨Ø¹...*


## 6.4 Ø£Ù†Ù…Ø§Ø· Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

### Ø§Ù„Ù†Ù…Ø· 5: Transactional Outbox with Change Data Capture (CDC)

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
Outbox Pattern ÙŠØªØ·Ù„Ø¨ pollingØŒ ÙˆÙ‡Ùˆ ØºÙŠØ± ÙØ¹Ø§Ù„.

**Ø§Ù„Ø­Ù„:**
CDC - Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„ØªØºÙŠÙŠØ±Ø§Øª Database Ù…Ø¨Ø§Ø´Ø±Ø©.

```php
// Debezium Ø£Ùˆ Maxwell's Daemon ÙŠÙ‚Ø±Ø£ binlog
class ChangeDataCaptureConsumer {
    public function __construct(
        private OutboxProcessor $processor,
        private LoggerInterface $logger
    ) {}
    
    public function consume(array $changeEvent): void {
        // binlog event: INSERT INTO outbox
        if ($changeEvent['table'] !== 'outbox') {
            return;
        }
        
        $this->logger->info('CDC event received', [
            'type' => $changeEvent['type'],
            'data' => $changeEvent['data']
        ]);
        
        $message = new OutboxMessage(
            id: $changeEvent['data']['id'],
            type: $changeEvent['data']['type'],
            payload: json_decode($changeEvent['data']['payload'], true)
        );
        
        $this->processor->process($message);
    }
}

// Ù„Ø§ polling! Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ ÙÙˆØ±ÙŠ
```

**Ø§Ù„ÙÙˆØ§Ø¦Ø¯:**
- Real-time processing
- Ù„Ø§ overhead Ø¹Ù„Ù‰ application
- Scalable

### Ø§Ù„Ù†Ù…Ø· 6: Idempotent Consumer

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª Ù‚Ø¯ ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø±Ø© (at-least-once delivery).

**Ø§Ù„Ø­Ù„:**
Idempotency Key.

```php
class IdempotentNotificationHandler {
    private ProcessedEventsRepository $processedEvents;
    
    public function handle(NotificationRequested $event): void {
        $idempotencyKey = $event->idempotencyKey();
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ Ø¹ÙÙˆÙ„Ø¬ Ø¨Ø§Ù„ÙØ¹Ù„
        if ($this->processedEvents->has($idempotencyKey)) {
            $this->logger->info('Event already processed, skipping', [
                'idempotency_key' => $idempotencyKey
            ]);
            return;
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø¯Ø«
        $this->notificationService->send($event);
        
        // ØªØ³Ø¬ÙŠÙ„ Ø£Ù†Ù‡ Ø¹ÙÙˆÙ„Ø¬
        $this->processedEvents->save($idempotencyKey, [
            'processed_at' => (new DateTimeImmutable())->format('c'),
            'result' => 'success'
        ]);
    }
}

// Ø§Ù„ØªØ®Ø²ÙŠÙ†
class ProcessedEventsRepository {
    private Cache $cache;
    private int $ttl = 86400 * 7;  // 7 days
    
    public function has(string $key): bool {
        return $this->cache->has("processed:{$key}");
    }
    
    public function save(string $key, array $data): void {
        $this->cache->set("processed:{$key}", $data, $this->ttl);
    }
}
```

### Ø§Ù„Ù†Ù…Ø· 7: Dead Letter Queue (DLQ)

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª ÙŠÙØ´Ù„ Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù….

**Ø§Ù„Ø­Ù„:**
Ø¹Ø²Ù„ Ø§Ù„ÙØ§Ø´Ù„Ø© ÙÙŠ queue Ù…Ù†ÙØµÙ„ Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©.

```php
class NotificationProcessor {
    private MessageQueue $queue;
    private MessageQueue $dlq;
    private int $maxRetries = 3;
    
    public function process(Message $message): void {
        $retryCount = $message->headers()['retry_count'] ?? 0;
        
        try {
            $this->doProcess($message);
            $this->queue->ack($message);
            
        } catch (RetryableException $e) {
            if ($retryCount < $this->maxRetries) {
                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
                $message->withHeader('retry_count', $retryCount + 1);
                $message->withHeader('retry_at', time() + $this->backoff($retryCount));
                $this->queue->requeue($message);
            } else {
                // Ø¥Ø±Ø³Ø§Ù„ Ù„Ù€ DLQ
                $this->dlq->send($message->withPayload([
                    'original_message' => $message->payload(),
                    'error' => $e->getMessage(),
                    'stack_trace' => $e->getTraceAsString(),
                    'failed_at' => (new DateTimeImmutable())->format('c'),
                    'retry_count' => $retryCount
                ]));
                
                $this->queue->ack($message);  // Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Queue Ø§Ù„Ø£ØµÙ„ÙŠØ©
            }
            
        } catch (NonRetryableException $e) {
            // Ù„Ø§ ÙŠØ³ØªØ­Ù‚ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© - Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù€ DLQ
            $this->dlq->send($message->withPayload([
                'original_message' => $message->payload(),
                'error' => $e->getMessage(),
                'failed_at' => (new DateTimeImmutable())->format('c'),
                'type' => 'non_retryable'
            ]));
            
            $this->queue->ack($message);
        }
    }
    
    private function backoff(int $retryCount): int {
        return [60, 300, 900][$retryCount] ?? 3600;
    }
}

// Ù…Ø±Ø§Ø¬Ø¹Ø© DLQ
class DLQReviewer {
    public function review(): void {
        $failedMessages = $this->dlq->peek(100);
        
        foreach ($failedMessages as $message) {
            // Ø¹Ø±Ø¶ ÙÙŠ Admin Dashboard
            // Ø¥Ù…ÙƒØ§Ù†ÙŠØ©:
            // - Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
            // - ØªØ¹Ø¯ÙŠÙ„ ÙˆØ¥Ø¹Ø§Ø¯Ø©
            // - Ø­Ø°Ù
            // - Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†
        }
    }
}
```

### Ø§Ù„Ù†Ù…Ø· 8: Bulk Operations

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
1000 Ø¥Ø´Ø¹Ø§Ø± ØªÙØ±Ø³Ù„ ÙˆØ§Ø­Ø¯Ø§Ù‹ ØªÙ„Ùˆ Ø§Ù„Ø¢Ø®Ø± = Ø¨Ø·ÙŠØ¡.

**Ø§Ù„Ø­Ù„:**
Bulk Operations.

```php
// ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
class BulkNotificationProcessor {
    private array $buffer = [];
    private int $batchSize = 100;
    private int $flushInterval = 5;  // seconds
    
    public function add(Notification $notification): void {
        $this->buffer[] = $notification;
        
        if (count($this->buffer) >= $this->batchSize) {
            $this->flush();
        }
    }
    
    public function flush(): void {
        if (empty($this->buffer)) {
            return;
        }
        
        $batch = $this->buffer;
        $this->buffer = [];
        
        // Ø¥Ø±Ø³Ø§Ù„ bulk Ù„Ù„Ù€ provider
        $results = $this->provider->sendBulk($batch);
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        foreach ($results as $index => $result) {
            if ($result->isSuccess()) {
                $batch[$index]->markAsSent($result->providerMessageId());
            } else {
                $batch[$index]->markAsFailed($result->error());
                
                if ($result->isRetryable()) {
                    $batch[$index]->scheduleRetry();
                }
            }
            
            $this->repository->save($batch[$index]);
        }
    }
}

// Provider ÙŠØ¯Ø¹Ù… Bulk
interface BulkNotificationProvider extends NotificationProvider {
    /**
     * @param Notification[] $notifications
     * @return ProviderResult[]
     */
    public function sendBulk(array $notifications): array;
}

class SendGridBulkProvider implements BulkNotificationProvider {
    public function sendBulk(array $notifications): array {
        $personalizations = array_map(
            fn($n) => [
                'to' => [['email' => $n->recipientEmail()]],
                'dynamic_template_data' => $n->templateData()
            ],
            $notifications
        );
        
        $response = $this->client->send([
            'personalizations' => $personalizations,
            'from' => ['email' => 'noreply@example.com'],
            'template_id' => $notifications[0]->templateId()
        ]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø±Ø¯ Ù„Ù€ results
        return array_map(
            fn($r) => $r['status'] === 'accepted' 
                ? ProviderResult::success($r['message_id'])
                : ProviderResult::failure($r['error']),
            $response->results()
        );
    }
}
```

---

## 6.5 Ø¯Ø±Ø§Ø³Ø© Ø­Ø§Ù„Ø©: Payment Processing System

### Ù†Ø¸Ø§Ù… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª

**Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª:**
1. Ù„Ø§ ÙŠÙ…ÙƒÙ† ÙÙ‚Ø¯Ø§Ù† Ø£ÙŠ Ù…Ø¹Ø§Ù…Ù„Ø©
2. Idempotency Ù…Ø·Ù„ÙˆØ¨Ø© (Ù„Ø§ Ø®ØµÙ… Ù…Ø²Ø¯ÙˆØ¬)
3. Integration Ù…Ø¹ Ø¹Ø¯Ø© Ø¨ÙˆØ§Ø¨Ø§Øª Ø¯ÙØ¹
4. Webhooks Ù„Ù„Ù€ merchants
5. Reporting ÙˆØ§Ù„Ù€ reconciliation

### Ø§Ù„Ø¨Ù†ÙŠØ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Merchant API                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Payment      â”‚
                â”‚   Service      â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚   Payment    â”‚ â”‚   Payment   â”‚ â”‚   Webhook   â”‚
â”‚   Aggregate  â”‚ â”‚   Gateway   â”‚ â”‚   Service   â”‚
â”‚   (Domain)   â”‚ â”‚   (Adapter) â”‚ â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â”‚               â”‚               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  Event Store â”‚ â”‚   Stripe    â”‚ â”‚  Merchants  â”‚
â”‚              â”‚ â”‚   / PayPal  â”‚ â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ø§Ù„ØªÙ†ÙÙŠØ°

#### 1. Payment Aggregate

```php
class Payment {
    private PaymentId $id;
    private MerchantId $merchantId;
    private Money $amount;
    private PaymentStatus $status;
    private ?string $providerTransactionId = null;
    private array $attempts = [];
    
    public static function create(
        PaymentId $id,
        MerchantId $merchantId,
        Money $amount,
        string $idempotencyKey
    ): self {
        $payment = new self();
        $payment->record(new PaymentCreated(
            id: $id,
            merchantId: $merchantId,
            amount: $amount,
            idempotencyKey: $idempotencyKey,
            createdAt: new DateTimeImmutable()
        ));
        return $payment;
    }
    
    public function initiateCharge(string $paymentMethod): void {
        if (!$this->status->isPending()) {
            throw new InvalidPaymentStateException();
        }
        
        $this->record(new PaymentChargeInitiated(
            paymentId: $this->id,
            amount: $this->amount,
            paymentMethod: $paymentMethod,
            initiatedAt: new DateTimeImmutable()
        ));
    }
    
    public function markAsCharged(string $providerTransactionId): void {
        $this->record(new PaymentCharged(
            paymentId: $this->id,
            providerTransactionId: $providerTransactionId,
            chargedAt: new DateTimeImmutable()
        ));
    }
    
    public function markAsFailed(string $error, bool $retryable): void {
        $this->record(new PaymentFailed(
            paymentId: $this->id,
            error: $error,
            retryable: $retryable,
            failedAt: new DateTimeImmutable()
        ));
    }
    
    public function refund(?Money $amount = null): void {
        if (!$this->status->isCharged()) {
            throw new InvalidRefundException();
        }
        
        $refundAmount = $amount ?? $this->amount;
        
        $this->record(new PaymentRefundRequested(
            paymentId: $this->id,
            amount: $refundAmount,
            requestedAt: new DateTimeImmutable()
        ));
    }
    
    protected function applyPaymentCreated(PaymentCreated $event): void {
        $this->id = $event->paymentId();
        $this->merchantId = $event->merchantId();
        $this->amount = $event->amount();
        $this->status = PaymentStatus::PENDING();
    }
    
    protected function applyPaymentCharged(PaymentCharged $event): void {
        $this->status = PaymentStatus::CHARGED();
        $this->providerTransactionId = $event->providerTransactionId();
    }
    
    protected function applyPaymentFailed(PaymentFailed $event): void {
        $this->status = $event->retryable() 
            ? PaymentStatus::RETRYABLE_FAILED() 
            : PaymentStatus::FAILED();
    }
}
```

#### 2. Payment Service

```php
class PaymentService {
    public function __construct(
        private PaymentRepository $payments,
        private PaymentGateway $gateway,
        private IdempotencyStore $idempotencyStore,
        private EventBus $eventBus
    ) {}
    
    public function charge(
        MerchantId $merchantId,
        Money $amount,
        PaymentMethod $method,
        string $idempotencyKey
    ): Payment {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Idempotency
        $existingPayment = $this->idempotencyStore->get($idempotencyKey);
        if ($existingPayment) {
            return $this->payments->find($existingPayment);
        }
        
        $payment = Payment::create(
            PaymentId::generate(),
            $merchantId,
            $amount,
            $idempotencyKey
        );
        
        try {
            $payment->initiateCharge($method->type());
            
            // Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù€ gateway
            $result = $this->gateway->charge([
                'amount' => $amount->cents(),
                'currency' => $amount->currency()->code(),
                'source' => $method->token(),
                'idempotency_key' => $idempotencyKey
            ]);
            
            if ($result->isSuccess()) {
                $payment->markAsCharged($result->transactionId());
            } else {
                $payment->markAsFailed($result->error(), $result->isRetryable());
            }
            
        } catch (Exception $e) {
            $payment->markAsFailed($e->getMessage(), true);
        }
        
        $this->payments->save($payment);
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù€ idempotency key
        $this->idempotencyStore->save($idempotencyKey, $payment->id()->toString());
        
        // Ù†Ø´Ø± Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
        foreach ($payment->releaseEvents() as $event) {
            $this->eventBus->publish($event);
        }
        
        return $payment;
    }
}
```

#### 3. Webhook Handler

```php
class PaymentWebhookHandler {
    public function handleStripeWebhook(array $payload): void {
        $event = $payload['type'];
        $data = $payload['data']['object'];
        
        match ($event) {
            'charge.succeeded' => $this->handleChargeSucceeded($data),
            'charge.failed' => $this->handleChargeFailed($data),
            'charge.refunded' => $this->handleChargeRefunded($data),
            'charge.dispute.created' => $this->handleDisputeCreated($data),
            default => $this->logger->info('Unhandled Stripe event', ['type' => $event])
        };
    }
    
    private function handleChargeSucceeded(array $data): void {
        $providerTransactionId = $data['id'];
        
        $payment = $this->payments->findByProviderTransactionId($providerTransactionId);
        
        if (!$payment || $payment->status()->isCharged()) {
            return;  // Already processed
        }
        
        $payment->markAsCharged($providerTransactionId);
        $this->payments->save($payment);
        
        $this->eventBus->publish(new PaymentConfirmedByProvider(
            paymentId: $payment->id(),
            providerTransactionId: $providerTransactionId
        ));
    }
}
```

#### 4. Webhook to Merchant

```php
class MerchantWebhookDispatcher {
    public function onPaymentCharged(PaymentCharged $event): void {
        $payment = $this->payments->find($event->paymentId());
        $merchant = $this->merchants->find($payment->merchantId());
        
        if (!$merchant->hasWebhookConfigured()) {
            return;
        }
        
        $webhookPayload = [
            'event' => 'payment.charged',
            'data' => [
                'payment_id' => $payment->id()->toString(),
                'amount' => $payment->amount()->cents(),
                'currency' => $payment->amount()->currency()->code(),
                'status' => 'charged',
                'charged_at' => $event->chargedAt()->format('c'),
            ]
        ];
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø´ÙƒÙ„ ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†
        $this->queue->publish('merchant_webhooks', [
            'merchant_id' => $merchant->id()->toString(),
            'url' => $merchant->webhookUrl(),
            'payload' => $webhookPayload,
            'signature' => $this->sign($webhookPayload, $merchant->webhookSecret())
        ]);
    }
    
    private function sign(array $payload, string $secret): string {
        return hash_hmac('sha256', json_encode($payload), $secret);
    }
}
```

### Reconciliation

```php
class PaymentReconciliation {
    public function reconcile(DateRange $range): ReconciliationReport {
        // Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª ÙÙŠ Ù†Ø¸Ø§Ù…Ù†Ø§
        $ourPayments = $this->payments->findInRange($range);
        
        // Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª ÙÙŠ Stripe
        $stripePayments = $this->stripe->listCharges([
            'created[gte]' => $range->start()->getTimestamp(),
            'created[lte]' => $range->end()->getTimestamp(),
            'limit' => 100
        ]);
        
        $matched = [];
        $discrepancies = [];
        
        foreach ($ourPayments as $payment) {
            $stripeCharge = $this->findMatchingStripeCharge($payment, $stripePayments);
            
            if (!$stripeCharge) {
                $discrepancies[] = [
                    'type' => 'missing_in_stripe',
                    'payment_id' => $payment->id()->toString(),
                    'amount' => $payment->amount()->format()
                ];
            } elseif (!$this->amountsMatch($payment, $stripeCharge)) {
                $discrepancies[] = [
                    'type' => 'amount_mismatch',
                    'payment_id' => $payment->id()->toString(),
                    'our_amount' => $payment->amount()->format(),
                    'stripe_amount' => $stripeCharge['amount'] / 100
                ];
            } else {
                $matched[] = $payment->id()->toString();
            }
        }
        
        return new ReconciliationReport(
            totalOurPayments: count($ourPayments),
            totalStripeCharges: count($stripePayments),
            matched: count($matched),
            discrepancies: $discrepancies
        );
    }
}
```

---

*ÙŠØªØ¨Ø¹ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£Ø®ÙŠØ±...*


## 6.6 Testing Side Effects

### Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
ÙƒÙŠÙ Ù†Ø®ØªØ¨Ø± Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø¯ÙˆÙ† Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø­Ù‚ÙŠÙ‚ÙŠØŸ

**Ø§Ù„Ø­Ù„:**
Test Doubles + Spy Pattern.

```php
// Spy Ù„Ù„Ù€ Email Service
class EmailServiceSpy implements NotificationService {
    private array $sentEmails = [];
    
    public function sendConfirmation(Order $order): void {
        $this->sentEmails[] = [
            'to' => $order->customerEmail(),
            'subject' => 'Order Confirmed',
            'order_id' => $order->id()->toString()
        ];
    }
    
    public function assertEmailSent(string $to, string $subject): void {
        foreach ($this->sentEmails as $email) {
            if ($email['to'] === $to && $email['subject'] === $subject) {
                return;
            }
        }
        
        throw new AssertionFailedError(
            "Expected email to '{$to}' with subject '{$subject}' was not sent"
        );
    }
    
    public function assertNoEmailsSent(): void {
        Assert::assertEmpty($this->sentEmails, 'Expected no emails to be sent');
    }
}

// Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
class OrderServiceTest {
    public function testConfirmOrderSendsEmail(): void {
        $emailSpy = new EmailServiceSpy();
        $service = new OrderService(
            $this->repository,
            $emailSpy,
            $this->eventBus
        );
        
        $order = Order::create(/* ... */);
        $this->repository->save($order);
        
        $service->confirmOrder($order->id());
        
        $emailSpy->assertEmailSent(
            'customer@example.com',
            'Order Confirmed'
        );
    }
    
    public function testFailedOrderDoesNotSendEmail(): void {
        $emailSpy = new EmailServiceSpy();
        $service = new OrderService(
            $this->repository,
            $emailSpy,
            $this->eventBus
        );
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯
        try {
            $service->confirmOrder(OrderId::generate());
        } catch (OrderNotFoundException $e) {
            // Ù…ØªÙˆÙ‚Ø¹
        }
        
        $emailSpy->assertNoEmailsSent();
    }
}
```

### Contract Testing

```php
// Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¹Ù‚Ø¯ Ø¨ÙŠÙ† Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ù€ Provider
interface PaymentGatewayContractTest {
    public function testChargeReturnsTransactionIdOnSuccess(): void;
    public function testChargeReturnsErrorOnFailure(): void;
    public function testChargeIsIdempotent(): void;
}

abstract class AbstractPaymentGatewayTest extends TestCase implements PaymentGatewayContractTest {
    abstract protected function createGateway(): PaymentGateway;
    
    public function testChargeReturnsTransactionIdOnSuccess(): void {
        $gateway = $this->createGateway();
        
        $result = $gateway->charge([
            'amount' => 1000,
            'currency' => 'USD',
            'source' => 'tok_visa'
        ]);
        
        Assert::assertTrue($result->isSuccess());
        Assert::assertNotEmpty($result->transactionId());
    }
    
    public function testChargeIsIdempotent(): void {
        $gateway = $this->createGateway();
        $idempotencyKey = 'test-key-' . uniqid();
        
        $result1 = $gateway->charge([
            'amount' => 1000,
            'currency' => 'USD',
            'source' => 'tok_visa',
            'idempotency_key' => $idempotencyKey
        ]);
        
        $result2 = $gateway->charge([
            'amount' => 1000,
            'currency' => 'USD',
            'source' => 'tok_visa',
            'idempotency_key' => $idempotencyKey
        ]);
        
        Assert::assertEquals($result1->transactionId(), $result2->transactionId());
    }
}

// Ø§Ø®ØªØ¨Ø§Ø± Stripe
class StripePaymentGatewayTest extends AbstractPaymentGatewayTest {
    protected function createGateway(): PaymentGateway {
        return new StripePaymentGateway(
            new StripeClient($_ENV['STRIPE_TEST_KEY'])
        );
    }
}
```

---

## 6.7 Performance Optimization

### ØªØ­Ø³ÙŠÙ† Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

**1. Async Processing:**
```php
// âŒ Ø³ÙŠØ¡: Ù…ØªØ²Ø§Ù…Ù†
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        $this->repository->save($order);
        
        // ÙŠØ­Ø¸Ø± Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©!
        $this->emailService->sendConfirmation($order);  // 500ms
        $this->searchIndex->update($order);             // 200ms
        $this->analytics->track('order_confirmed');     // 100ms
    }  // Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØªØ£Ø®Ø±Øª 800ms!
}

// âœ… Ø¬ÙŠØ¯: ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        $this->repository->save($order);
        
        // Ù†Ø´Ø± Ø­Ø¯Ø« ÙÙ‚Ø· - Ø³Ø±ÙŠØ¹!
        $this->eventBus->publish(new OrderConfirmed($order->id()));
    }  // Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙÙˆØ±ÙŠØ©!
}
```

**2. Batching:**
```php
class BatchEmailProcessor {
    private array $buffer = [];
    private int $batchSize = 100;
    private Timer $flushTimer;
    
    public function enqueue(Email $email): void {
        $this->buffer[] = $email;
        
        if (count($this->buffer) >= $this->batchSize) {
            $this->flush();
        }
    }
    
    public function flush(): void {
        if (empty($this->buffer)) {
            return;
        }
        
        // Ø¥Ø±Ø³Ø§Ù„ batch ÙˆØ§Ø­Ø¯ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† 100 request
        $this->sendGrid->sendBulk($this->buffer);
        
        $this->buffer = [];
    }
}
```

**3. Connection Pooling:**
```php
class PooledSmtpClient {
    private array $pool = [];
    private int $maxConnections = 10;
    
    public function send(Email $email): void {
        $connection = $this->getConnection();
        try {
            $connection->send($email);
        } finally {
            $this->releaseConnection($connection);
        }
    }
    
    private function getConnection(): SmtpConnection {
        if (!empty($this->pool)) {
            return array_pop($this->pool);
        }
        
        if (count($this->pool) < $this->maxConnections) {
            return new SmtpConnection();
        }
        
        throw new PoolExhaustedException();
    }
}
```

---

## Ø®Ø§ØªÙ…Ø© Ø§Ù„ÙØµÙ„ Ø§Ù„Ø³Ø§Ø¯Ø³

### Ù…Ø§ ØªØ¹Ù„Ù…Ù†Ø§Ù‡

**1. Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª:**
- Ø£ÙŠ ØªØºÙŠÙŠØ± Ø®Ø§Ø±Ø¬ Ø§Ù„Ù€ Domain
- ÙŠØªØ·Ù„Ø¨ Ø¹Ù†Ø§ÙŠØ© Ø®Ø§ØµØ© ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ…
- ÙŠØ¤Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„Ù…ÙˆØ«ÙˆÙ‚ÙŠØ©

**2. Ø§Ù„Ù…Ø¨Ø§Ø¯Ø¦ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:**
- **Ø¹Ø²Ù„:** ÙØµÙ„ Ø§Ù„Ø£Ø«Ø± ÙÙŠ abstraction
- **ØªØ£Ø¬ÙŠÙ„:** async processing
- **Ù‚Ø§Ø¨Ù„ÙŠØ© Ø§Ù„ØªÙƒØ±Ø§Ø±:** idempotency

**3. Ø§Ù„Ø£Ù†Ù…Ø§Ø·:**
- Outbox Pattern
- Event-Driven Side Effects
- Saga with Compensation
- Circuit Breaker
- Change Data Capture
- Dead Letter Queue
- Bulk Operations

**4. Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ÙŠ:**
- Ù†Ø¸Ø§Ù… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…ØªÙƒØ§Ù…Ù„
- Ù†Ø¸Ø§Ù… Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø¯ÙÙˆØ¹Ø§Øª

### Ø§Ù„Ù†ØµÙŠØ­Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©

> "Ù„Ø§ ØªØ®Ù Ù…Ù† Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª. Ø®Ù Ù…Ù† Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª ØºÙŠØ± Ø§Ù„Ù…ÙØ¯Ø§Ø±."

### Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙØµÙ„

| Ø§Ù„Ù…Ù‚ÙŠØ§Ø³ | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ø£Ù‚Ø³Ø§Ù…** | 7 Ø£Ù‚Ø³Ø§Ù… |
| **Ø§Ù„Ø£Ù†Ù…Ø§Ø·** | 8 Ø£Ù†Ù…Ø§Ø· |
| **Ø¯Ø±Ø§Ø³Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø©** | 2 |

---

**Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙØµÙ„ Ø§Ù„Ø³Ø§Ø¯Ø³ - Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª** âœ…

**Â© 2025 Ù…Ø­Ù…Ø¯ Ø§Ù„Ø¹Ø¨ÙŠØ¯ | Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠ**



## 6.6 Testing Side Effects

### Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

**Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:**
ÙƒÙŠÙ Ù†Ø®ØªØ¨Ø± Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø¯ÙˆÙ† Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø­Ù‚ÙŠÙ‚ÙŠØŸ

**Ø§Ù„Ø­Ù„:**
Test Doubles + Spy Pattern.

```php
// Spy Ù„Ù„Ù€ Email Service
class EmailServiceSpy implements NotificationService {
    private array $sentEmails = [];
    
    public function sendConfirmation(Order $order): void {
        $this->sentEmails[] = [
            'to' => $order->customerEmail(),
            'subject' => 'Order Confirmed',
            'order_id' => $order->id()->toString()
        ];
    }
    
    public function assertEmailSent(string $to, string $subject): void {
        foreach ($this->sentEmails as $email) {
            if ($email['to'] === $to && $email['subject'] === $subject) {
                return;
            }
        }
        
        throw new AssertionFailedError(
            "Expected email to '{$to}' with subject '{$subject}' was not sent"
        );
    }
    
    public function assertNoEmailsSent(): void {
        Assert::assertEmpty($this->sentEmails, 'Expected no emails to be sent');
    }
}

// Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
class OrderServiceTest {
    public function testConfirmOrderSendsEmail(): void {
        $emailSpy = new EmailServiceSpy();
        $service = new OrderService(
            $this->repository,
            $emailSpy,
            $this->eventBus
        );
        
        $order = Order::create(/* ... */);
        $this->repository->save($order);
        
        $service->confirmOrder($order->id());
        
        $emailSpy->assertEmailSent(
            'customer@example.com',
            'Order Confirmed'
        );
    }
    
    public function testFailedOrderDoesNotSendEmail(): void {
        $emailSpy = new EmailServiceSpy();
        $service = new OrderService(
            $this->repository,
            $emailSpy,
            $this->eventBus
        );
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯
        try {
            $service->confirmOrder(OrderId::generate());
        } catch (OrderNotFoundException $e) {
            // Ù…ØªÙˆÙ‚Ø¹
        }
        
        $emailSpy->assertNoEmailsSent();
    }
}
```

### Contract Testing

```php
// Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¹Ù‚Ø¯ Ø¨ÙŠÙ† Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ù€ Provider
interface PaymentGatewayContractTest {
    public function testChargeReturnsTransactionIdOnSuccess(): void;
    public function testChargeReturnsErrorOnFailure(): void;
    public function testChargeIsIdempotent(): void;
}

abstract class AbstractPaymentGatewayTest extends TestCase implements PaymentGatewayContractTest {
    abstract protected function createGateway(): PaymentGateway;
    
    public function testChargeReturnsTransactionIdOnSuccess(): void {
        $gateway = $this->createGateway();
        
        $result = $gateway->charge([
            'amount' => 1000,
            'currency' => 'USD',
            'source' => 'tok_visa'
        ]);
        
        Assert::assertTrue($result->isSuccess());
        Assert::assertNotEmpty($result->transactionId());
    }
    
    public function testChargeIsIdempotent(): void {
        $gateway = $this->createGateway();
        $idempotencyKey = 'test-key-' . uniqid();
        
        $result1 = $gateway->charge([
            'amount' => 1000,
            'currency' => 'USD',
            'source' => 'tok_visa',
            'idempotency_key' => $idempotencyKey
        ]);
        
        $result2 = $gateway->charge([
            'amount' => 1000,
            'currency' => 'USD',
            'source' => 'tok_visa',
            'idempotency_key' => $idempotencyKey
        ]);
        
        Assert::assertEquals($result1->transactionId(), $result2->transactionId());
    }
}

// Ø§Ø®ØªØ¨Ø§Ø± Stripe
class StripePaymentGatewayTest extends AbstractPaymentGatewayTest {
    protected function createGateway(): PaymentGateway {
        return new StripePaymentGateway(
            new StripeClient($_ENV['STRIPE_TEST_KEY'])
        );
    }
}
```

---

## 6.7 Performance Optimization

### ØªØ­Ø³ÙŠÙ† Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª

**1. Async Processing:**
```php
// âŒ Ø³ÙŠØ¡: Ù…ØªØ²Ø§Ù…Ù†
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        $this->repository->save($order);
        
        // ÙŠØ­Ø¸Ø± Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©!
        $this->emailService->sendConfirmation($order);  // 500ms
        $this->searchIndex->update($order);             // 200ms
        $this->analytics->track('order_confirmed');     // 100ms
    }  // Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØªØ£Ø®Ø±Øª 800ms!
}

// âœ… Ø¬ÙŠØ¯: ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†
class OrderService {
    public function confirmOrder(OrderId $id): void {
        $order = $this->repository->find($id);
        $order->confirm();
        $this->repository->save($order);
        
        // Ù†Ø´Ø± Ø­Ø¯Ø« ÙÙ‚Ø· - Ø³Ø±ÙŠØ¹!
        $this->eventBus->publish(new OrderConfirmed($order->id()));
    }  // Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙÙˆØ±ÙŠØ©!
}
```

**2. Batching:**
```php
class BatchEmailProcessor {
    private array $buffer = [];
    private int $batchSize = 100;
    private Timer $flushTimer;
    
    public function enqueue(Email $email): void {
        $this->buffer[] = $email;
        
        if (count($this->buffer) >= $this->batchSize) {
            $this->flush();
        }
    }
    
    public function flush(): void {
        if (empty($this->buffer)) {
            return;
        }
        
        // Ø¥Ø±Ø³Ø§Ù„ batch ÙˆØ§Ø­Ø¯ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† 100 request
        $this->sendGrid->sendBulk($this->buffer);
        
        $this->buffer = [];
    }
}
```

**3. Connection Pooling:**
```php
class PooledSmtpClient {
    private array $pool = [];
    private int $maxConnections = 10;
    
    public function send(Email $email): void {
        $connection = $this->getConnection();
        try {
            $connection->send($email);
        } finally {
            $this->releaseConnection($connection);
        }
    }
    
    private function getConnection(): SmtpConnection {
        if (!empty($this->pool)) {
            return array_pop($this->pool);
        }
        
        if (count($this->pool) < $this->maxConnections) {
            return new SmtpConnection();
        }
        
        throw new PoolExhaustedException();
    }
}
```

---

## Ø®Ø§ØªÙ…Ø© Ø§Ù„ÙØµÙ„ Ø§Ù„Ø³Ø§Ø¯Ø³

### Ù…Ø§ ØªØ¹Ù„Ù…Ù†Ø§Ù‡

**1. Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª:**
- Ø£ÙŠ ØªØºÙŠÙŠØ± Ø®Ø§Ø±Ø¬ Ø§Ù„Ù€ Domain
- ÙŠØªØ·Ù„Ø¨ Ø¹Ù†Ø§ÙŠØ© Ø®Ø§ØµØ© ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ…
- ÙŠØ¤Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„Ù…ÙˆØ«ÙˆÙ‚ÙŠØ©

**2. Ø§Ù„Ù…Ø¨Ø§Ø¯Ø¦ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:**
- **Ø¹Ø²Ù„:** ÙØµÙ„ Ø§Ù„Ø£Ø«Ø± ÙÙŠ abstraction
- **ØªØ£Ø¬ÙŠÙ„:** async processing
- **Ù‚Ø§Ø¨Ù„ÙŠØ© Ø§Ù„ØªÙƒØ±Ø§Ø±:** idempotency

**3. Ø§Ù„Ø£Ù†Ù…Ø§Ø·:**
- Outbox Pattern
- Event-Driven Side Effects
- Saga with Compensation
- Circuit Breaker
- Change Data Capture
- Dead Letter Queue
- Bulk Operations

**4. Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ÙŠ:**
- Ù†Ø¸Ø§Ù… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…ØªÙƒØ§Ù…Ù„
- Ù†Ø¸Ø§Ù… Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø¯ÙÙˆØ¹Ø§Øª

### Ø§Ù„Ù†ØµÙŠØ­Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©

> "Ù„Ø§ ØªØ®Ù Ù…Ù† Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª. Ø®Ù Ù…Ù† Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª ØºÙŠØ± Ø§Ù„Ù…ÙØ¯Ø§Ø±."

### Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙØµÙ„

| Ø§Ù„Ù…Ù‚ÙŠØ§Ø³ | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ø£Ù‚Ø³Ø§Ù…** | 7 Ø£Ù‚Ø³Ø§Ù… |
| **Ø§Ù„Ø£Ù†Ù…Ø§Ø·** | 8 Ø£Ù†Ù…Ø§Ø· |
| **Ø¯Ø±Ø§Ø³Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø©** | 2 |

---

**Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙØµÙ„ Ø§Ù„Ø³Ø§Ø¯Ø³ - Ø§Ù„Ø£Ø«Ø± Ø§Ù„ØµØ§Ù…Øª** âœ…

**Â© 2025 Ù…Ø­Ù…Ø¯ Ø§Ù„Ø¹Ø¨ÙŠØ¯ | Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠ**

