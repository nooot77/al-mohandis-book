# الفصل الخامس: السيادة الزمنية

## الزمن كبعد معماري

---

## مقدمة: لماذا الزمن مهم؟

> "معظم الأنظمة تُصمم كأن الوقت مجرد ثابت. الأنظمة العظيمة تُصمم مع إدراك أن الوقت هو البعد الرابع للحقيقة."

في عالم يتغير باستمرار، يبرز الزمن كأحد أهم الأبعاد التي يجب على المعماري فهمها وإتقانها. ليس مجرد خلفية للأحداث، بل **قوة فاعلة** تشكل كيفية عمل أنظمتنا.

### الأبعاد الأربعة للنظام

```
┌─────────────────────────────────────────────────────────────┐
│                    الأبعاد الأربعة                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  X - البعد المكاني (Space)                                  │
│      ←→ توزيع الخدمات جغرافياً                             │
│                                                             │
│  Y - البعد المنطقي (Logic)                                  │
│      ↑↓ طبقات التطبيق والمجال                              │
│                                                             │
│  Z - البعد التقني (Technology)                              │
│      ○ اختيار التقنيات والأدوات                            │
│                                                             │
│  T - البعد الزمني (Time) ⭐                                  │
│      ⏱️ تدفق الأحداث والتغييرات                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### لماذا نهمل الزمن؟

**المشكلة الشائعة:**
معظم الأنظمة تُصمم لـ "الآن" (Now):
- الحالة الحالية فقط
- آخر قيمة فقط
- لا تاريخ، لا سياق

**النتيجة:**
```
"لماذا وصلنا لهذه النتيجة؟"
"لا نعرف، لقد فقدنا التاريخ."

"متى حدث هذا؟"
"لا نعرف، ليس لدينا سجل."

"من قام بهذا التغيير؟"
"لا نعرف، لم نسجل."
```

### الفرق بين النظام "الآني" والنظام "الزمني"

| الجانب | النظام الآني | النظام الزمني |
|--------|-------------|--------------|
| **البيانات** | الحالة الحالية فقط | تاريخ كامل للتغييرات |
| **الاستعلام** | ما هي القيمة؟ | ما كانت القيمة في X؟ |
| **التصحيح** | صعب أو مستحيل | سهل عبر replay |
| **التحليل** | محدود | عميق (trends, patterns) |
| **الثقة** | منخفضة | عالية |

---

## 5.1 أسس الفهم الزمني

### النماذج الزمنية

#### 1. النموذج الآني (Snapshot Model)

**المفهوم:**
نخزن الحالة الحالية فقط.

**المثال:**
```sql
-- جدول حساب بنكي تقليدي
CREATE TABLE accounts (
    id VARCHAR(36) PRIMARY KEY,
    customer_id VARCHAR(36),
    balance DECIMAL(15,2),  -- ← الرصيد الحالي فقط
    updated_at TIMESTAMP
);
```

**المشاكل:**
```sql
-- سؤال: ما كان الرصيد في 1 يناير؟
-- جواب: لا نعرف! فقدنا التاريخ.

-- سؤال: من قام بتحويل 1000 ريال؟
-- جواب: لا نعرف! لا سجل.

-- سؤال: كيف وصلنا لهذا الرصيد؟
-- جواب: لا نعرف! لا تتبع.
```

#### 2. النموذج الزمني (Temporal Model)

**المفهوم:**
نخزن تاريخ التغييرات كاملاً.

**المثال:**
```sql
-- Event Log
CREATE TABLE account_events (
    id VARCHAR(36) PRIMARY KEY,
    account_id VARCHAR(36),
    event_type VARCHAR(50),     -- 'AccountOpened', 'MoneyDeposited', etc.
    payload JSON,               -- بيانات الحدث
    occurred_at TIMESTAMP,
    version INT                 -- تسلسل الأحداث
);

-- الحالة الحالية يمكن إعادة بنائها:
-- AccountOpened (+0) → MoneyDeposited (+1000) → MoneyWithdrawn (-300) → ...
```

**الإمكانيات:**
```sql
-- سؤال: ما كان الرصيد في 1 يناير؟
-- جواب: نعيد تشغيل الأحداث حتى هذا التاريخ.

-- سؤال: من قام بتحويل 1000 ريال؟
-- جواب: نبحث في الأحداث.

-- سؤال: كيف وصلنا لهذا الرصيد؟
-- جواب: قائمة كاملة بالأحداث.
```

### الـ Event كوحدة زمنية

**تعريف الـ Event:**
حدث (Event) هو وصف لشيء حدث في الماضي.

**الخصائص:**
```php
interface DomainEvent {
    public function id(): EventId;                    // معرف فريد
    public function occurredAt(): DateTimeImmutable;  // وقت الحدوث
    public function aggregateId(): string;            // معرف الـ Aggregate
    public function version(): int;                   // رقم الإصدار
}

// مثال: حدث إيداع مبلغ
final class MoneyDeposited implements DomainEvent {
    public function __construct(
        private EventId $id,
        private DateTimeImmutable $occurredAt,
        private AccountId $accountId,
        private Money $amount,
        private string $description,
        private int $version
    ) {}
    
    public function accountId(): AccountId {
        return $this->accountId;
    }
    
    public function amount(): Money {
        return $this->amount;
    }
    
    // ... implementation of interface methods
}
```

### الـ Aggregate كخط زمني

**المفهوم:**
كل Aggregate هو خط زمني (timeline) من الأحداث.

**الرسم:**
```
Account Timeline:
Time →

T1: AccountOpened (balance: 0)
    │
T2: MoneyDeposited (+1000) → balance: 1000
    │
T3: MoneyWithdrawn (-300) → balance: 700
    │
T4: MoneyDeposited (+500) → balance: 1200
    │
T5: MoneyTransferred (-200) → balance: 1000
    │
Now: balance: 1000 (current state)
```

**الكود:**
```php
class Account {
    private AccountId $id;
    private Money $balance;
    private int $version = 0;
    private array $uncommittedEvents = [];
    
    // Factory method: بدء خط زمني جديد
    public static function open(AccountId $id, CustomerId $customerId): self {
        $account = new self();
        $account->apply(new AccountOpened($id, $customerId, new Money(0, 'USD')));
        return $account;
    }
    
    // إعادة بناء من تاريخ الأحداث
    public static function reconstitute(AccountId $id, array $events): self {
        $account = new self();
        foreach ($events as $event) {
            $account->apply($event);
        }
        return $account;
    }
    
    // العمليات تُنشئ أحداثاً
    public function deposit(Money $amount, string $description): void {
        if ($amount->isNegativeOrZero()) {
            throw new InvalidArgumentException('Amount must be positive');
        }
        
        $this->apply(new MoneyDeposited(
            $this->id,
            $amount,
            $description,
            ++$this->version
        ));
    }
    
    public function withdraw(Money $amount, string $description): void {
        if ($amount->isGreaterThan($this->balance)) {
            throw new InsufficientFundsException();
        }
        
        $this->apply(new MoneyWithdrawn(
            $this->id,
            $amount,
            $description,
            ++$this->version
        ));
    }
    
    // تطبيق الحدث يُغير الحالة
    private function apply(DomainEvent $event): void {
        match (get_class($event)) {
            AccountOpened::class => $this->applyAccountOpened($event),
            MoneyDeposited::class => $this->applyMoneyDeposited($event),
            MoneyWithdrawn::class => $this->applyMoneyWithdrawn($event),
        };
        
        $this->uncommittedEvents[] = $event;
    }
    
    private function applyAccountOpened(AccountOpened $event): void {
        $this->id = $event->accountId();
        $this->balance = new Money(0, 'USD');
    }
    
    private function applyMoneyDeposited(MoneyDeposited $event): void {
        $this->balance = $this->balance->add($event->amount());
    }
    
    private function applyMoneyWithdrawn(MoneyWithdrawn $event): void {
        $this->balance = $this->balance->subtract($event->amount());
    }
    
    public function releaseEvents(): array {
        $events = $this->uncommittedEvents;
        $this->uncommittedEvents = [];
        return $events;
    }
}
```

---

## 5.2 Event Sourcing بعمق

### ما هو Event Sourcing؟

**التعريف:**
Event Sourcing هو pattern نخزن فيه تاريخ الأحداث كمصدر حقيقة (source of truth)، بدلاً من تخزين الحالة الحالية فقط.

**المبدأ الأساسي:**
```
الأحداث ← مصدر الحقيقة
الحالة ← projection من الأحداث
```

**الفرق:**

| التقليدي | Event Sourcing |
|---------|---------------|
| UPDATE accounts SET balance = 1200 | INSERT INTO events (type: 'MoneyDeposited', amount: 500) |
| الحالة تُستبدل | الأحداث تُضاف |
| فقدان التاريخ | تاريخ كامل |

### البنية التقنية

#### 1. Event Store

**المسؤوليات:**
- تخزين الأحداث بشكل دائم
- استرجاع الأحداث بترتيبها
- ضمان التسلسل (ordering)
- توفير التفاؤلية في التزامن

**التنفيذ:**
```php
interface EventStore {
    /**
     * حفظ أحداث جديدة
     * @throws ConcurrencyException إذا كان الإصدار متعارضاً
     */
    public function append(
        string $streamId,
        int $expectedVersion,
        array $events
    ): void;
    
    /**
     * قراءة جميع أحداث stream
     */
    public function readStream(string $streamId): EventStream;
    
    /**
     * قراءة من إصدار محدد
     */
    public function readFromVersion(string $streamId, int $version): EventStream;
}

// تنفيذ PostgreSQL
final class PostgreSqlEventStore implements EventStore {
    private Connection $connection;
    
    public function append(
        string $streamId,
        int $expectedVersion,
        array $events
    ): void {
        $this->connection->transactional(function() use ($streamId, $expectedVersion, $events) {
            // التحقق من التفاؤلية في التزامن (Optimistic Concurrency)
            $currentVersion = $this->getCurrentVersion($streamId);
            
            if ($currentVersion !== $expectedVersion) {
                throw new ConcurrencyException(
                    "Expected version {$expectedVersion} but found {$currentVersion}"
                );
            }
            
            // إدراج الأحداث
            foreach ($events as $index => $event) {
                $this->connection->insert('events', [
                    'stream_id' => $streamId,
                    'version' => $expectedVersion + $index + 1,
                    'event_type' => get_class($event),
                    'payload' => json_encode($this->serialize($event)),
                    'metadata' => json_encode([
                        'occurred_at' => $event->occurredAt()->format('c'),
                        'user_id' => $event->userId()?->toString(),
                    ]),
                    'recorded_at' => (new DateTimeImmutable())->format('c'),
                ]);
            }
        });
    }
    
    private function getCurrentVersion(string $streamId): int {
        $result = $this->connection->fetchOne(
            'SELECT MAX(version) FROM events WHERE stream_id = ?',
            [$streamId]
        );
        
        return $result ? (int) $result : 0;
    }
    
    public function readStream(string $streamId): EventStream {
        $rows = $this->connection->fetchAll(
            'SELECT * FROM events 
             WHERE stream_id = ? 
             ORDER BY version ASC',
            [$streamId]
        );
        
        return new EventStream(array_map(
            fn($row) => $this->deserialize($row),
            $rows
        ));
    }
}
```

#### 2. Snapshotting (للأداء)

**المشكلة:**
إذا كان لدينا 100,000 حدث، إعادة بناء Aggregate قد تكون بطيئة.

**الحل:**
Snapshots: صور دورية من الحالة.

```php
class Snapshot {
    public function __construct(
        public readonly string $streamId,
        public readonly int $version,
        public readonly object $state,  // الحالة المُجمَّعة
        public readonly DateTimeImmutable $createdAt
    ) {}
}

interface SnapshotStore {
    public function save(Snapshot $snapshot): void;
    public function getLatest(string $streamId): ?Snapshot;
}

class AccountRepository {
    private EventStore $eventStore;
    private SnapshotStore $snapshotStore;
    private int $snapshotFrequency = 100; // كل 100 حدث
    
    public function find(AccountId $id): Account {
        // محاولة الحصول على snapshot
        $snapshot = $this->snapshotStore->getLatest($id->toString());
        
        if ($snapshot) {
            // إعادة بناء من snapshot + الأحداث اللاحقة
            $account = $snapshot->state;
            $events = $this->eventStore->readFromVersion(
                $id->toString(),
                $snapshot->version
            );
        } else {
            // إعادة بناء من البداية
            $events = $this->eventStore->readStream($id->toString());
            $account = new Account();
        }
        
        foreach ($events as $event) {
            $account->apply($event);
        }
        
        return $account;
    }
    
    public function save(Account $account): void {
        $events = $account->releaseEvents();
        $expectedVersion = $account->version() - count($events);
        
        $this->eventStore->append(
            $account->id()->toString(),
            $expectedVersion,
            $events
        );
        
        // إنشاء snapshot إذا لزم
        if ($account->version() % $this->snapshotFrequency === 0) {
            $this->snapshotStore->save(new Snapshot(
                $account->id()->toString(),
                $account->version(),
                clone $account,
                new DateTimeImmutable()
            ));
        }
    }
}
```

#### 3. Projections (Read Models)

**المفهوم:**
أنماط للقراءة مُحسَّنة ومُبنية من الأحداث.

```php
// Projection: قائمة الحسابات للعرض
class AccountListProjection {
    private Connection $readDb;
    
    public function handle(AccountOpened $event): void {
        $this->readDb->insert('account_list', [
            'id' => $event->accountId()->toString(),
            'customer_id' => $event->customerId()->toString(),
            'opened_at' => $event->occurredAt()->format('c'),
            'status' => 'active',
        ]);
    }
    
    public function handle(MoneyDeposited $event): void {
        $this->readDb->execute(
            'UPDATE account_list 
             SET balance = balance + ?,
                 last_activity = ?
             WHERE id = ?',
            [
                $event->amount()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
    
    public function handle(AccountClosed $event): void {
        $this->readDb->update('account_list',
            ['status' => 'closed', 'closed_at' => $event->occurredAt()->format('c')],
            ['id' => $event->accountId()->toString()]
        );
    }
}

// Query Handler يستخدم Projection
class GetAccountListHandler {
    private Connection $readDb;
    
    public function handle(GetAccountListQuery $query): array {
        return $this->readDb->fetchAll(
            'SELECT * FROM account_list 
             WHERE status = ? 
             ORDER BY opened_at DESC 
             LIMIT ? OFFSET ?',
            [$query->status(), $query->limit(), $query->offset()]
        );
    }
}
```

### مزايا Event Sourcing

**1. Audit Trail كامل**
كل تغيير مسجل: متى، من، ماذا.

**2. Time Travel**
إعادة النظام لأي نقطة زمنية.

**3. Debugging ممتاز**
```
"لماذا وصلنا لهذه الحالة؟"
→ قائمة الأحداث توضح كل خطوة.
```

**4. Analytics غنية**
Trends, patterns, forecasting من تاريخ الأحداث.

**5. Recovery من الفشل**
إعادة بناء الحالة من الأحداث.

### تحديات Event Sourcing

**1. التعقيد**
أكثر تعقيداً من CRUD.

**2. Learning Curve**
الفريق يحتاج للتدريب.

**3. Event Schema Evolution**
كيف تتعامل مع تغيير هيكل Events؟

```php
// الإصدار 1
class OrderCreated {
    public function __construct(
        public readonly OrderId $orderId,
        public readonly Money $total,  // في الإصدار 1 كان total فقط
    ) {}
}

// الإصدار 2: نحتاج لـ currency منفصلة
class OrderCreated {
    public function __construct(
        public readonly OrderId $orderId,
        public readonly Money $total,
        public readonly Currency $currency, // حقل جديد
    ) {}
    
    // Upgrader للأحداث القديمة
    public static function upgrade(array $oldData): self {
        return new self(
            OrderId::fromString($oldData['orderId']),
            new Money($oldData['total'], Currency::USD()), // افتراض USD للقديم
        );
    }
}
```

**4. Consistency**
الـ Read Models تكون eventually consistent.

**5. Storage**
حجم أكبر (لكن compression يُساعد).

### متى تستخدم Event Sourcing؟

**استخدمه عندما:**
- Audit trail مهم (banking, finance)
- Debugging صعب (complex domains)
- Analytics غنية مطلوبة
- Recovery مهم
- الفريق جاهز للتعقيد

**لا تستخدمه عندما:**
- نظام بسيط CRUD
- الفريق غير جاهز
- Performance critical جداً
- لا حاجة للتاريخ

---

*يتبع...*


---

## 5.3 أنماط الـ Temporal

### النمط 1: Temporal Database

**المفهوم:**
قاعدة بيانات تدعم الوقت أولاً (first-class time support).

**الأنواع:**
- **System-Time (Transaction Time):** وقت تسجيل البيانات في النظام
- **Valid-Time (Application Time):** وقت صلاحية البيانات في الواقع
- **Bitemporal:** كلاهما معاً

**التنفيذ في PostgreSQL:**
```sql
-- جدارة Bitemporal
CREATE TABLE contracts (
    id UUID PRIMARY KEY,
    customer_id UUID,
    terms TEXT,
    
    -- Valid Time: وقت صلاحية العقد
    valid_start DATE,
    valid_end DATE,
    
    -- System Time: وقت تسجيله في النظام
    sys_start TIMESTAMP GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (sys_start, sys_end)
) WITH (SYSTEM_VERSIONING = ON);

-- استعلام: ما كان ساري المفعول في 2023؟
SELECT * FROM contracts
FOR SYSTEM_TIME AS OF '2023-06-01'
WHERE valid_start <= '2023-06-01' AND valid_end > '2023-06-01';
```

**الاستخدام:**
- Financial records
- Legal documents
- Compliance

### النمط 2: CQRS (Command Query Responsibility Segregation)

**المفهوم:**
فصل أوامر الكتابة عن استعلامات القراءة.

**الهيكل:**
```
┌─────────────────┐     ┌─────────────────┐
│   Commands      │     │    Queries      │
│  (Write Side)   │     │  (Read Side)    │
│                 │     │                 │
│ Domain Model    │     │   Projections   │
│ Event Sourcing  │────▶│   Read Models   │
│                 │     │                 │
└─────────────────┘     └─────────────────┘
```

**التنفيذ:**
```php
// Command Side (Write)
class DepositMoneyCommand {
    public function __construct(
        public readonly AccountId $accountId,
        public readonly Money $amount,
        public readonly string $description
    ) {}
}

class DepositMoneyHandler {
    private AccountRepository $accounts;
    private EventBus $eventBus;
    
    public function handle(DepositMoneyCommand $command): void {
        $account = $this->accounts->find($command->accountId);
        
        $account->deposit($command->amount, $command->description);
        
        $this->accounts->save($account);
        
        // نشر الأحداث للـ Read Side
        foreach ($account->releaseEvents() as $event) {
            $this->eventBus->publish($event);
        }
    }
}

// Query Side (Read)
class AccountBalanceQuery {
    public function __construct(
        public readonly AccountId $accountId
    ) {}
}

class AccountBalanceProjection {
    private Connection $readDb;
    
    public function onMoneyDeposited(MoneyDeposited $event): void {
        $this->readDb->execute(
            'UPDATE account_balances 
             SET balance = balance + ?,
                 last_deposit = ?,
                 last_activity = ?
             WHERE account_id = ?',
            [
                $event->amount()->cents(),
                $event->amount()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
    
    public function onMoneyWithdrawn(MoneyWithdrawn $event): void {
        $this->readDb->execute(
            'UPDATE account_balances 
             SET balance = balance - ?,
                 last_withdrawal = ?,
                 last_activity = ?
             WHERE account_id = ?',
            [
                $event->amount()->cents(),
                $event->amount()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
}

class GetAccountBalanceHandler {
    private Connection $readDb;
    
    public function handle(AccountBalanceQuery $query): AccountBalanceDto {
        $row = $this->readDb->fetchOne(
            'SELECT * FROM account_balances WHERE account_id = ?',
            [$query->accountId->toString()]
        );
        
        return new AccountBalanceDto(
            accountId: $query->accountId,
            balance: Money::fromCents($row['balance'], Currency::fromCode($row['currency'])),
            lastActivity: new DateTimeImmutable($row['last_activity'])
        );
    }
}
```

**المزايا:**
- Read Models مُحسَّنة للاستعلامات
- Write Models مُحسَّنة للـ business logic
- Scale كل جانب بشكل منفصل

**التحديات:**
- Eventual consistency
- Complexity إضافي
- Synchronization challenges

### النمط 3: Saga (المعاملة الموزعة)

**المفهوم:**
إدارة معاملة (transaction) عبر multiple aggregates/services.

**الأنواع:**

**Choreography:**
كل خدمة تُكمل عملها وتُرسِل حدثاً للتالية.

**Orchestration:**
مدير مركزي (orchestrator) يُنسق الخطوات.

**التنفيذ:**
```php
// Orchestration Saga
class OrderProcessingSaga {
    private SagaStateRepository $stateRepo;
    private OrderService $orders;
    private PaymentService $payment;
    private InventoryService $inventory;
    private ShippingService $shipping;
    
    public function execute(OrderId $orderId): void {
        $saga = Saga::start('order_processing', $orderId);
        
        try {
            // الخطوة 1: معالجة الدفع
            $saga->step('payment', function() use ($orderId) {
                $order = $this->orders->find($orderId);
                return $this->payment->process($order->paymentRequest());
            });
            
            // الخطوة 2: حجز المخزون
            $saga->step('inventory', function($paymentResult) use ($orderId) {
                $order = $this->orders->find($orderId);
                return $this->inventory->reserve($order->items());
            });
            
            // الخطوة 3: إنشاء الشحنة
            $saga->step('shipping', function($inventoryResult) use ($orderId) {
                $order = $this->orders->find($orderId);
                return $this->shipping->createShipment($order);
            });
            
            $saga->complete();
            
        } catch (Exception $e) {
            $saga->compensate(); // التراجع عن الخطوات
            throw $e;
        }
    }
}

// Compensation (التراجع)
interface Compensatable {
    public function compensate(): void;
}

class PaymentStep implements Compensatable {
    private PaymentGateway $gateway;
    private TransactionId $transactionId;
    
    public function execute(): void {
        $result = $this->gateway->charge(/* ... */);
        $this->transactionId = $result->transactionId();
    }
    
    public function compensate(): void {
        if ($this->transactionId) {
            $this->gateway->refund($this->transactionId);
        }
    }
}
```

### النمط 4: Process Manager

**المفهوم:**
يدير workflow معقدة عبر الوقت.

**الفرق عن Saga:**
- Saga: معاملة واحدة (成功 أو فشل)
- Process Manager: workflow طويل المدى (قد تستمر أيام/أسابيع)

**التنفيذ:**
```php
class OrderFulfillmentProcess {
    private ProcessState $state;
    
    public function handle($event): void {
        match($this->state->currentStep()) {
            'awaiting_payment' => $this->onPaymentReceived($event),
            'awaiting_inventory' => $this->onInventoryReserved($event),
            'awaiting_shipping' => $this->onShipped($event),
            'delivered' => $this->onDelivered($event),
        };
    }
    
    private function onPaymentReceived(PaymentReceived $event): void {
        if ($event->orderId() !== $this->state->orderId()) {
            return;
        }
        
        $this->state->transitionTo('awaiting_inventory');
        $this->inventoryService->reserve($this->state->items());
    }
    
    private function onInventoryReserved(InventoryReserved $event): void {
        $this->state->transitionTo('awaiting_shipping');
        $this->shippingService->ship($this->state->orderId());
    }
    
    private function onShipped(OrderShipped $event): void {
        $this->state->transitionTo('delivered');
        $this->notificationService->notifyCustomer($this->state->customerId());
    }
}
```

### النمط 5: Deadline Pattern

**المفهوم:**
إدارة المواعيد النهائية (deadlines) في النظام.

**التنفيذ:**
```php
class PaymentDeadlineManager {
    private Scheduler $scheduler;
    private PaymentRepository $payments;
    
    public function scheduleDeadline(PaymentId $paymentId, DateTimeImmutable $deadline): void {
        $this->scheduler->schedule(
            job: new CancelPaymentIfNotCompleted($paymentId),
            at: $deadline
        );
    }
    
    public function cancelDeadline(PaymentId $paymentId): void {
        $this->scheduler->cancel("payment_deadline:{$paymentId->toString()}");
    }
}

class CancelPaymentIfNotCompleted implements Job {
    private PaymentId $paymentId;
    
    public function handle(): void {
        $payment = $this->payments->find($this->paymentId);
        
        if ($payment->status()->isPending()) {
            $payment->cancelDueToTimeout();
            $this->payments->save($payment);
        }
    }
}
```

---

## 5.4 Consistency في الزمن

### أنواع Consistency

#### 1. Strong Consistency

**المفهوم:**
جميع القراء ترى أحدث كتابة.

**التنفيذ:**
```
Write → A (تأكيد) → Read A → ترى القيمة الجديدة
```

**متى تستخدم:**
- Financial transactions
- Inventory management
- Critical business rules

#### 2. Eventual Consistency

**المفهوم:**
في النهاية جميع القراء ستترى نفس القيمة، لكن قد يكون هناك تأخير.

**التنفيذ:**
```
Write → A (async) → Read A → قد ترى القديم
                        ↓
                      بعد وقت → ترى الجديد
```

**متى تستخدم:**
- Social media feeds
- Analytics dashboards
- Non-critical read models

#### 3. Causal Consistency

**المفهوم:**
إذا حدث A قبل B، فجميع يرون A قبل B.

**التنفيذ:**
```
User writes A → then writes B
All users see A before B (or neither)
```

### إدارة Consistency في Distributed Systems

**التحدي:**
CAP Theorem: لا يمكن تحقيق Consistency + Availability + Partition Tolerance في نفس الوقت.

**الاستراتيجيات:**

**1. Two-Phase Commit (2PC)**
```
Coordinator                    Participants
     │                             │
     ├──── Prepare? ──────────────▶│
     │                             │ (write to log)
     │◀──── Yes/No ────────────────┤
     │                             │
     ├──── Commit ────────────────▶│ (if all Yes)
     │                             │ (apply changes)
     │◀──── ACK ───────────────────┤
```

**المشكلة:** Blocking, slow, coordinator single point of failure.

**2. Saga Pattern (سبق شرحه)**
Compensating transactions بدلاً من rollback.

**3. Conflict-Free Replicated Data Types (CRDTs)**
```php
// G-Counter (Grow-only Counter)
class GCounter {
    private array $values = []; // node => value
    
    public function increment(string $node): void {
        $this->values[$node] = ($this->values[$node] ?? 0) + 1;
    }
    
    public function value(): int {
        return array_sum($this->values);
    }
    
    public function merge(GCounter $other): void {
        foreach ($other->values as $node => $value) {
            $this->values[$node] = max(
                $this->values[$node] ?? 0,
                $value
            );
        }
    }
}

// الاستخدام: Counters موزعة
$node1 = new GCounter();
$node1->increment('A');
$node1->increment('A'); // value = 2

$node2 = new GCounter();
$node2->increment('B'); // value = 1

// Merge
$node1->merge($node2); // value = 3 (2 + 1)
```

**المزايا:**
- No coordination needed
- Always available
- Eventually consistent

---

## 5.5 دراسة حالة: نظام مالي زمني

### المتطلبات

**النظام:**
- إدارة حسابات بنكية
- تحويلات دولية
- تقارير تنظيمية (regulatory reporting)
- Audit trail كامل

**التحديات:**
1. لا يمكن فقدان أي معاملة
2. Audit trail مطلوب من regulators
3. Consistency قوية للـ balances
4. Performance للـ queries

### البنية

```
┌─────────────────────────────────────────────────────────────┐
│                      Frontend (Web/Mobile)                   │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                   API Gateway                                │
│        (Authentication, Rate Limiting, Routing)              │
└───────────────────────┬─────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼──────┐
│  Command     │ │   Query     │ │  Process   │
│   Service    │ │   Service   │ │  Manager   │
│   (Write)    │ │   (Read)    │ │            │
└───────┬──────┘ └──────┬──────┘ └─────┬──────┘
        │               │              │
┌───────▼───────────────▼──────────────▼──────┐
│              Event Store                     │
│         (Event Sourcing)                     │
└───────────────────────┬──────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼──────┐
│  Account     │ │ Transaction │ │  Reporting │
│ Projection   │ │  Projection │ │ Projection │
└──────────────┘ └─────────────┘ └────────────┘
```

### التنفيذ

**1. Aggregate: Account (مع Event Sourcing)**
```php
class Account {
    use EventSourcedAggregate;
    
    private AccountId $id;
    private Money $balance;
    private AccountStatus $status;
    private array $pendingTransfers = [];
    
    public static function open(AccountId $id, CustomerId $customerId, Currency $currency): self {
        return self::record(new AccountOpened($id, $customerId, $currency));
    }
    
    public function deposit(Money $amount, string $reference): void {
        $this->assertActive();
        $this->assertCurrencyMatches($amount);
        
        $this->record(new MoneyDeposited(
            accountId: $this->id,
            amount: $amount,
            reference: $reference,
            newBalance: $this->balance->add($amount)
        ));
    }
    
    public function withdraw(Money $amount, string $reference): void {
        $this->assertActive();
        $this->assertSufficientFunds($amount);
        
        $this->record(new MoneyWithdrawn(
            accountId: $this->id,
            amount: $amount,
            reference: $reference,
            newBalance: $this->balance->subtract($amount)
        ));
    }
    
    public function initiateTransfer(Money $amount, AccountId $toAccount): TransferId {
        $this->assertActive();
        $this->assertSufficientFunds($amount);
        
        $transferId = TransferId::generate();
        
        $this->record(new TransferInitiated(
            transferId: $transferId,
            fromAccount: $this->id,
            toAccount: $toAccount,
            amount: $amount
        ));
        
        return $transferId;
    }
    
    // Event handlers
    protected function applyAccountOpened(AccountOpened $event): void {
        $this->id = $event->accountId();
        $this->balance = Money::zero($event->currency());
        $this->status = AccountStatus::ACTIVE;
    }
    
    protected function applyMoneyDeposited(MoneyDeposited $event): void {
        $this->balance = $event->newBalance();
    }
    
    protected function applyMoneyWithdrawn(MoneyWithdrawn $event): void {
        $this->balance = $event->newBalance();
    }
}
```

**2. Process Manager: Transfer Processing**
```php
class TransferProcessManager {
    private TransferRepository $transfers;
    private AccountRepository $accounts;
    private ForexService $forex;
    private SwiftService $swift;
    
    public function onTransferInitiated(TransferInitiated $event): void {
        $transfer = $this->transfers->find($event->transferId());
        
        // الخطوة 1: حجز المبلغ في الحساب المصدر
        $fromAccount = $this->accounts->find($event->fromAccount());
        $fromAccount->debit($event->amount(), "Transfer {$event->transferId()}");
        $this->accounts->save($fromAccount);
        
        $transfer->markAsDebited();
        
        // الخطوة 2: إذا كانت عملة مختلفة، تحويل العملة
        if ($transfer->requiresCurrencyExchange()) {
            $rate = $this->forex->getRate(
                $transfer->sourceCurrency(),
                $transfer->targetCurrency()
            );
            $transfer->applyExchangeRate($rate);
        }
        
        // الخطوة 3: إرسال عبر SWIFT
        $swiftMessage = $this->swift->createMessage($transfer);
        $swiftRef = $this->swift->send($swiftMessage);
        
        $transfer->markAsSent($swiftRef);
        $this->transfers->save($transfer);
    }
    
    public function onSwiftConfirmation(SwiftConfirmationReceived $event): void {
        $transfer = $this->transfers->findBySwiftRef($event->swiftRef());
        
        // الخطوة 4: إيداع في الحساب المستهدف
        $toAccount = $this->accounts->find($transfer->toAccount());
        $toAccount->credit($transfer->convertedAmount(), "Transfer {$transfer->id()}");
        $this->accounts->save($toAccount);
        
        $transfer->markAsCompleted();
        $this->transfers->save($transfer);
    }
}
```

**3. Projections للقراءة**
```php
// Projection: رصيد الحساب للعرض
class AccountBalanceProjection {
    private Connection $readDb;
    
    public function onMoneyDeposited(MoneyDeposited $event): void {
        $this->readDb->execute(
            'INSERT INTO account_transactions 
             (account_id, type, amount, balance_after, reference, occurred_at)
             VALUES (?, ?, ?, ?, ?, ?)',
            [
                $event->accountId()->toString(),
                'deposit',
                $event->amount()->cents(),
                $event->newBalance()->cents(),
                $event->reference(),
                $event->occurredAt()->format('c')
            ]
        );
        
        $this->readDb->execute(
            'UPDATE account_balances 
             SET balance = ?, last_activity = ?
             WHERE account_id = ?',
            [
                $event->newBalance()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
}

// Projection: تقارير تنظيمية
class RegulatoryReportProjection {
    public function onMoneyDeposited(MoneyDeposited $event): void {
        if ($event->amount()->isGreaterThan(Money::fromDecimal(10000, 'USD'))) {
            // Large Transaction Report (للـ regulators)
            $this->readDb->insert('large_transactions', [
                'account_id' => $event->accountId()->toString(),
                'amount' => $event->amount()->cents(),
                'reference' => $event->reference(),
                'reported_at' => (new DateTimeImmutable())->format('c'),
            ]);
        }
    }
}
```

### النتائج

**قبل (Nosql تقليدي):**
- Audit trail: لا يوجد
- Debugging: صعب
- Regulatory compliance: manual

**بعد (Event Sourcing):**
- Audit trail: كامل تلقائياً
- Debugging: سهل عبر replay
- Regulatory compliance: تلقائي

---



## 5.6 التحسينات والـ Performance

### تحسين Event Store

**1. Partitioning**
```sql
-- تقسيم الأحداث حسب التاريخ
CREATE TABLE events_2024 PARTITION OF events
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE events_2025 PARTITION OF events
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**2. Indexing Strategy**
```sql
-- Index للبحث السريع
CREATE INDEX CONCURRENTLY idx_events_stream_version 
    ON events(stream_id, version);

CREATE INDEX CONCURRENTLY idx_events_occurred 
    ON events(occurred_at);

CREATE INDEX CONCURRENTLY idx_events_type 
    ON events(event_type);
```

**3. Archiving**
```php
class EventArchiver {
    public function archiveOldEvents(DateTimeImmutable $before): void {
        // نقل الأحداث القديمة لـ cold storage
        $events = $this->eventStore->readBefore($before);
        
        foreach ($events as $event) {
            $this->coldStorage->store($event);
            $this->eventStore->markAsArchived($event->id());
        }
    }
}
```

### Caching Strategies

**1. Snapshot Caching**
```php
class CachedSnapshotStore implements SnapshotStore {
    private SnapshotStore $inner;
    private Cache $cache;
    
    public function getLatest(string $streamId): ?Snapshot {
        $key = "snapshot:{$streamId}";
        
        $cached = $this->cache->get($key);
        if ($cached) {
            return $cached;
        }
        
        $snapshot = $this->inner->getLatest($streamId);
        if ($snapshot) {
            $this->cache->set($key, $snapshot, 3600); // 1 hour
        }
        
        return $snapshot;
    }
}
```

**2. Projection Caching**
```php
class CachedAccountBalanceProjection {
    private AccountBalanceProjection $inner;
    private Cache $cache;
    
    public function getBalance(AccountId $id): Money {
        $key = "balance:{$id->toString()}";
        
        $cached = $this->cache->get($key);
        if ($cached) {
            return Money::fromCents($cached['amount'], Currency::fromCode($cached['currency']));
        }
        
        $balance = $this->inner->getBalance($id);
        
        $this->cache->set($key, [
            'amount' => $balance->cents(),
            'currency' => $balance->currency()->code()
        ], 60); // 1 minute
        
        return $balance;
    }
    
    public function onMoneyDeposited(MoneyDeposited $event): void {
        $this->inner->onMoneyDeposited($event);
        
        // Invalidate cache
        $this->cache->delete("balance:{$event->accountId()->toString()}");
    }
}
```

### Batch Processing

**لـ Projections:**
```php
class BatchProjection {
    private Connection $db;
    private array $buffer = [];
    private int $batchSize = 100;
    
    public function handle(DomainEvent $event): void {
        $this->buffer[] = $this->transform($event);
        
        if (count($this->buffer) >= $this->batchSize) {
            $this->flush();
        }
    }
    
    public function flush(): void {
        if (empty($this->buffer)) {
            return;
        }
        
        $this->db->transactional(function() {
            foreach ($this->buffer as $record) {
                $this->db->insert('projection_table', $record);
            }
        });
        
        $this->buffer = [];
    }
}
```

---

## 5.7 Testing في الأنظمة الزمنية

### Testing Event Sourced Aggregates

**1. Given-When-Then**
```php
class AccountTest extends TestCase {
    use EventSourcedAggregateTestCase;
    
    public function testCanDepositMoney(): void {
        $this->given(
            new AccountOpened(AccountId::generate(), CustomerId::generate(), Currency::USD())
        )
        ->when(fn(Account $account) => $account->deposit(Money::fromDecimal(100, 'USD'), 'Salary'))
        ->then(
            new MoneyDeposited(/* ... */)
        );
    }
    
    public function testCannotWithdrawMoreThanBalance(): void {
        $this->given(
            new AccountOpened(AccountId::generate(), CustomerId::generate(), Currency::USD()),
            new MoneyDeposited(/* ... 50 USD */)
        )
        ->when(fn(Account $account) => $account->withdraw(Money::fromDecimal(100, 'USD'), 'Purchase'))
        ->expectException(InsufficientFundsException::class);
    }
}
```

**2. Time Travel Testing**
```php
class TimeTravelTest extends TestCase {
    public function testAccountStateAtSpecificTime(): void {
        $account = Account::open(AccountId::generate(), CustomerId::generate(), Currency::USD());
        
        // T1
        Clock::freeze(new DateTimeImmutable('2024-01-01'));
        $account->deposit(Money::fromDecimal(100, 'USD'), 'Deposit 1');
        
        // T2
        Clock::freeze(new DateTimeImmutable('2024-02-01'));
        $account->withdraw(Money::fromDecimal(30, 'USD'), 'Withdrawal 1');
        
        // T3
        Clock::freeze(new DateTimeImmutable('2024-03-01'));
        $account->deposit(Money::fromDecimal(50, 'USD'), 'Deposit 2');
        
        // Test: ما كان الرصيد في 15 يناير؟
        $stateAtJan15 = $account->stateAt(new DateTimeImmutable('2024-01-15'));
        $this->assertEquals(Money::fromDecimal(100, 'USD'), $stateAtJan15->balance());
        
        // Test: ما كان الرصيد في 15 فبراير؟
        $stateAtFeb15 = $account->stateAt(new DateTimeImmutable('2024-02-15'));
        $this->assertEquals(Money::fromDecimal(70, 'USD'), $stateAtFeb15->balance());
    }
}
```

### Testing Sagas

```php
class OrderProcessingSagaTest extends TestCase {
    use SagaTestCase;
    
    public function testSuccessfulOrderProcessing(): void {
        $saga = $this->startSaga(OrderProcessingSaga::class);
        
        // الخطوة 1
        $saga->handle(new OrderCreated(/* ... */));
        $this->assertDispatched(ReserveInventory::class);
        
        // الخطوة 2
        $saga->handle(new InventoryReserved(/* ... */));
        $this->assertDispatched(ProcessPayment::class);
        
        // الخطوة 3
        $saga->handle(new PaymentProcessed(/* ... */));
        $this->assertDispatched(CreateShipment::class);
        
        // الخطوة 4
        $saga->handle(new ShipmentCreated(/* ... */));
        $this->assertSagaCompleted();
    }
    
    public function testCompensationOnFailure(): void {
        $saga = $this->startSaga(OrderProcessingSaga::class);
        
        $saga->handle(new OrderCreated(/* ... */));
        $saga->handle(new InventoryReserved(/* ... */));
        
        // فشل الدفع
        $saga->handle(new PaymentFailed(/* ... */));
        
        // يجب التعويض
        $this->assertDispatched(ReleaseInventory::class);
        $this->assertSagaFailed();
    }
}
```

---

## 5.8 Anti-patterns الزمنية

### 1. Event Sourcing كل شيء

**المشكلة:**
استخدام Event Sourcing حتى للبيانات البسيطة.

**الحل:**
استخدم Event Sourcing للـ Aggregates المعقدة فقط.
استخدم CRUD للبيانات البسيطة.

### 2. Events بدون Schema

**المشكلة:**
JSON غير منظم يصعب التطوير.

**الحل:**
استخدم Typed Events مع versioning.

### 3. Projection سريع جداً

**المشكلة:**
تحديث projections بشكل متزامن يؤدي لـ latency.

**الحل:**
Async projections مع tolerance للـ eventual consistency.

### 4. ignoring Time Zones

**المشكلة:**
تخزين وقت بدون timezone.

**الحل:**
دائماً استخدم UTC في التخزين، وconvert للعرض.

### 5. Large Aggregates

**المشكلة:**
Aggregate واحد يحتوي على آلاف الأحداث.

**الحل:**
استخدم Snapshotting أو قسّم Aggregate.

---

## خاتمة الفصل الخامس

### ما تعلمناه

**الأساسيات:**
- الزمن كبعد معماري رابع
- الفرق بين النماذج الآنية والزمنية
- Event كوحدة زمنية أساسية

**Event Sourcing:**
- Source of truth هو تاريخ الأحداث
- Snapshots للأداء
- Projections للقراءة

**الأنماط:**
- Temporal Database
- CQRS
- Saga Pattern
- Process Manager
- Deadline Pattern

**Consistency:**
- Strong vs Eventual
- 2PC, Saga, CRDTs
- Trade-offs ومتى تستخدم كل واحد

**التطبيق العملي:**
- دراسة حالة نظام مالي
- Testing strategies
- Performance optimizations
- Anti-patterns

### متى تبني نظاماً زمنياً؟

**ابنِ نظاماً زمنياً عندما:**
- Audit trail مهم
- Debugging معقد
- تحليل تاريخي مطلوب
- Recovery مهم

**لا تبنِ نظاماً زمنياً عندما:**
- البيانات بسيطة وثابتة
- Performance أولوية قصوى
- الفريق غير جاهز
- الـ use case واضح ولا يحتاج تاريخ

### إلى الأمام

في الفصول القادمة، سنستكشف:
- **الفصل السادس:** الأثر الصامت (Side Effects)
- **الفصل السابع:** معمارية المؤسسة
- **الفصل الثامن:** الأمن السيادي

---

**© 2025 محمد العبيد | المعماري**

*"السيادة الحقيقية على حرفتك"*

**نهاية الفصل الخامس - السيادة الزمنية**

---

