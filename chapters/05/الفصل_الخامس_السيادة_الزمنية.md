# الفصل الخامس: السيادة الزمنية

## الزمن كبعد معماري

---

## مقدمة: لماذا الزمن مهم؟

> "معظم الأنظمة تُصمم كأن الوقت مجرد ثابت. الأنظمة العظيمة تُصمم مع إدراك أن الوقت هو البعد الرابع للحقيقة."

في عالم يتغير باستمرار، يبرز الزمن كأحد أهم الأبعاد التي يجب على المعماري فهمها وإتقانها. ليس مجرد خلفية للأحداث، بل **قوة فاعلة** تشكل كيفية عمل أنظمتنا.

### الأبعاد الأربعة للنظام

```
┌─────────────────────────────────────────────────────────────┐
│                    الأبعاد الأربعة                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  X - البعد المكاني (Space)                                  │
│      ←→ توزيع الخدمات جغرافياً                             │
│                                                             │
│  Y - البعد المنطقي (Logic)                                  │
│      ↑↓ طبقات التطبيق والمجال                              │
│                                                             │
│  Z - البعد التقني (Technology)                              │
│      ○ اختيار التقنيات والأدوات                            │
│                                                             │
│  T - البعد الزمني (Time) ⭐                                  │
│      ⏱️ تدفق الأحداث والتغييرات                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### لماذا نهمل الزمن؟

**المشكلة الشائعة:**
معظم الأنظمة تُصمم لـ "الآن" (Now):
- الحالة الحالية فقط
- آخر قيمة فقط
- لا تاريخ، لا سياق

**النتيجة:**
```
"لماذا وصلنا لهذه النتيجة؟"
"لا نعرف، لقد فقدنا التاريخ."

"متى حدث هذا؟"
"لا نعرف، ليس لدينا سجل."

"من قام بهذا التغيير؟"
"لا نعرف، لم نسجل."
```

### الفرق بين النظام "الآني" والنظام "الزمني"

| الجانب | النظام الآني | النظام الزمني |
|--------|-------------|--------------|
| **البيانات** | الحالة الحالية فقط | تاريخ كامل للتغييرات |
| **الاستعلام** | ما هي القيمة؟ | ما كانت القيمة في X؟ |
| **التصحيح** | صعب أو مستحيل | سهل عبر replay |
| **التحليل** | محدود | عميق (trends, patterns) |
| **الثقة** | منخفضة | عالية |

---

## 5.1 أسس الفهم الزمني

### النماذج الزمنية

#### 1. النموذج الآني (Snapshot Model)

**المفهوم:**
نخزن الحالة الحالية فقط.

**المثال:**
```sql
-- جدول حساب بنكي تقليدي
CREATE TABLE accounts (
    id VARCHAR(36) PRIMARY KEY,
    customer_id VARCHAR(36),
    balance DECIMAL(15,2),  -- ← الرصيد الحالي فقط
    updated_at TIMESTAMP
);
```

**المشاكل:**
```sql
-- سؤال: ما كان الرصيد في 1 يناير؟
-- جواب: لا نعرف! فقدنا التاريخ.

-- سؤال: من قام بتحويل 1000 ريال؟
-- جواب: لا نعرف! لا سجل.

-- سؤال: كيف وصلنا لهذا الرصيد؟
-- جواب: لا نعرف! لا تتبع.
```

#### 2. النموذج الزمني (Temporal Model)

**المفهوم:**
نخزن تاريخ التغييرات كاملاً.

**المثال:**
```sql
-- Event Log
CREATE TABLE account_events (
    id VARCHAR(36) PRIMARY KEY,
    account_id VARCHAR(36),
    event_type VARCHAR(50),     -- 'AccountOpened', 'MoneyDeposited', etc.
    payload JSON,               -- بيانات الحدث
    occurred_at TIMESTAMP,
    version INT                 -- تسلسل الأحداث
);

-- الحالة الحالية يمكن إعادة بنائها:
-- AccountOpened (+0) → MoneyDeposited (+1000) → MoneyWithdrawn (-300) → ...
```

**الإمكانيات:**
```sql
-- سؤال: ما كان الرصيد في 1 يناير؟
-- جواب: نعيد تشغيل الأحداث حتى هذا التاريخ.

-- سؤال: من قام بتحويل 1000 ريال؟
-- جواب: نبحث في الأحداث.

-- سؤال: كيف وصلنا لهذا الرصيد؟
-- جواب: قائمة كاملة بالأحداث.
```

### الـ Event كوحدة زمنية

**تعريف الـ Event:**
حدث (Event) هو وصف لشيء حدث في الماضي.

**الخصائص:**
```php
interface DomainEvent {
    public function id(): EventId;                    // معرف فريد
    public function occurredAt(): DateTimeImmutable;  // وقت الحدوث
    public function aggregateId(): string;            // معرف الـ Aggregate
    public function version(): int;                   // رقم الإصدار
}

// مثال: حدث إيداع مبلغ
final class MoneyDeposited implements DomainEvent {
    public function __construct(
        private EventId $id,
        private DateTimeImmutable $occurredAt,
        private AccountId $accountId,
        private Money $amount,
        private string $description,
        private int $version
    ) {}
    
    public function accountId(): AccountId {
        return $this->accountId;
    }
    
    public function amount(): Money {
        return $this->amount;
    }
    
    // ... implementation of interface methods
}
```

### الـ Aggregate كخط زمني

**المفهوم:**
كل Aggregate هو خط زمني (timeline) من الأحداث.

**الرسم:**
```
Account Timeline:
Time →

T1: AccountOpened (balance: 0)
    │
T2: MoneyDeposited (+1000) → balance: 1000
    │
T3: MoneyWithdrawn (-300) → balance: 700
    │
T4: MoneyDeposited (+500) → balance: 1200
    │
T5: MoneyTransferred (-200) → balance: 1000
    │
Now: balance: 1000 (current state)
```

**الكود:**
```php
class Account {
    private AccountId $id;
    private Money $balance;
    private int $version = 0;
    private array $uncommittedEvents = [];
    
    // Factory method: بدء خط زمني جديد
    public static function open(AccountId $id, CustomerId $customerId): self {
        $account = new self();
        $account->apply(new AccountOpened($id, $customerId, new Money(0, 'USD')));
        return $account;
    }
    
    // إعادة بناء من تاريخ الأحداث
    public static function reconstitute(AccountId $id, array $events): self {
        $account = new self();
        foreach ($events as $event) {
            $account->apply($event);
        }
        return $account;
    }
    
    // العمليات تُنشئ أحداثاً
    public function deposit(Money $amount, string $description): void {
        if ($amount->isNegativeOrZero()) {
            throw new InvalidArgumentException('Amount must be positive');
        }
        
        $this->apply(new MoneyDeposited(
            $this->id,
            $amount,
            $description,
            ++$this->version
        ));
    }
    
    public function withdraw(Money $amount, string $description): void {
        if ($amount->isGreaterThan($this->balance)) {
            throw new InsufficientFundsException();
        }
        
        $this->apply(new MoneyWithdrawn(
            $this->id,
            $amount,
            $description,
            ++$this->version
        ));
    }
    
    // تطبيق الحدث يُغير الحالة
    private function apply(DomainEvent $event): void {
        match (get_class($event)) {
            AccountOpened::class => $this->applyAccountOpened($event),
            MoneyDeposited::class => $this->applyMoneyDeposited($event),
            MoneyWithdrawn::class => $this->applyMoneyWithdrawn($event),
        };
        
        $this->uncommittedEvents[] = $event;
    }
    
    private function applyAccountOpened(AccountOpened $event): void {
        $this->id = $event->accountId();
        $this->balance = new Money(0, 'USD');
    }
    
    private function applyMoneyDeposited(MoneyDeposited $event): void {
        $this->balance = $this->balance->add($event->amount());
    }
    
    private function applyMoneyWithdrawn(MoneyWithdrawn $event): void {
        $this->balance = $this->balance->subtract($event->amount());
    }
    
    public function releaseEvents(): array {
        $events = $this->uncommittedEvents;
        $this->uncommittedEvents = [];
        return $events;
    }
}
```

---

## 5.2 Event Sourcing بعمق

### ما هو Event Sourcing؟

**التعريف:**
Event Sourcing هو pattern نخزن فيه تاريخ الأحداث كمصدر حقيقة (source of truth)، بدلاً من تخزين الحالة الحالية فقط.

**المبدأ الأساسي:**
```
الأحداث ← مصدر الحقيقة
الحالة ← projection من الأحداث
```

**الفرق:**

| التقليدي | Event Sourcing |
|---------|---------------|
| UPDATE accounts SET balance = 1200 | INSERT INTO events (type: 'MoneyDeposited', amount: 500) |
| الحالة تُستبدل | الأحداث تُضاف |
| فقدان التاريخ | تاريخ كامل |

### البنية التقنية

#### 1. Event Store

**المسؤوليات:**
- تخزين الأحداث بشكل دائم
- استرجاع الأحداث بترتيبها
- ضمان التسلسل (ordering)
- توفير التفاؤلية في التزامن

**التنفيذ:**
```php
interface EventStore {
    /**
     * حفظ أحداث جديدة
     * @throws ConcurrencyException إذا كان الإصدار متعارضاً
     */
    public function append(
        string $streamId,
        int $expectedVersion,
        array $events
    ): void;
    
    /**
     * قراءة جميع أحداث stream
     */
    public function readStream(string $streamId): EventStream;
    
    /**
     * قراءة من إصدار محدد
     */
    public function readFromVersion(string $streamId, int $version): EventStream;
}

// تنفيذ PostgreSQL
final class PostgreSqlEventStore implements EventStore {
    private Connection $connection;
    
    public function append(
        string $streamId,
        int $expectedVersion,
        array $events
    ): void {
        $this->connection->transactional(function() use ($streamId, $expectedVersion, $events) {
            // التحقق من التفاؤلية في التزامن (Optimistic Concurrency)
            $currentVersion = $this->getCurrentVersion($streamId);
            
            if ($currentVersion !== $expectedVersion) {
                throw new ConcurrencyException(
                    "Expected version {$expectedVersion} but found {$currentVersion}"
                );
            }
            
            // إدراج الأحداث
            foreach ($events as $index => $event) {
                $this->connection->insert('events', [
                    'stream_id' => $streamId,
                    'version' => $expectedVersion + $index + 1,
                    'event_type' => get_class($event),
                    'payload' => json_encode($this->serialize($event)),
                    'metadata' => json_encode([
                        'occurred_at' => $event->occurredAt()->format('c'),
                        'user_id' => $event->userId()?->toString(),
                    ]),
                    'recorded_at' => (new DateTimeImmutable())->format('c'),
                ]);
            }
        });
    }
    
    private function getCurrentVersion(string $streamId): int {
        $result = $this->connection->fetchOne(
            'SELECT MAX(version) FROM events WHERE stream_id = ?',
            [$streamId]
        );
        
        return $result ? (int) $result : 0;
    }
    
    public function readStream(string $streamId): EventStream {
        $rows = $this->connection->fetchAll(
            'SELECT * FROM events 
             WHERE stream_id = ? 
             ORDER BY version ASC',
            [$streamId]
        );
        
        return new EventStream(array_map(
            fn($row) => $this->deserialize($row),
            $rows
        ));
    }
}
```

#### 2. Snapshotting (للأداء)

**المشكلة:**
إذا كان لدينا 100,000 حدث، إعادة بناء Aggregate قد تكون بطيئة.

**الحل:**
Snapshots: صور دورية من الحالة.

```php
class Snapshot {
    public function __construct(
        public readonly string $streamId,
        public readonly int $version,
        public readonly object $state,  // الحالة المُجمَّعة
        public readonly DateTimeImmutable $createdAt
    ) {}
}

interface SnapshotStore {
    public function save(Snapshot $snapshot): void;
    public function getLatest(string $streamId): ?Snapshot;
}

class AccountRepository {
    private EventStore $eventStore;
    private SnapshotStore $snapshotStore;
    private int $snapshotFrequency = 100; // كل 100 حدث
    
    public function find(AccountId $id): Account {
        // محاولة الحصول على snapshot
        $snapshot = $this->snapshotStore->getLatest($id->toString());
        
        if ($snapshot) {
            // إعادة بناء من snapshot + الأحداث اللاحقة
            $account = $snapshot->state;
            $events = $this->eventStore->readFromVersion(
                $id->toString(),
                $snapshot->version
            );
        } else {
            // إعادة بناء من البداية
            $events = $this->eventStore->readStream($id->toString());
            $account = new Account();
        }
        
        foreach ($events as $event) {
            $account->apply($event);
        }
        
        return $account;
    }
    
    public function save(Account $account): void {
        $events = $account->releaseEvents();
        $expectedVersion = $account->version() - count($events);
        
        $this->eventStore->append(
            $account->id()->toString(),
            $expectedVersion,
            $events
        );
        
        // إنشاء snapshot إذا لزم
        if ($account->version() % $this->snapshotFrequency === 0) {
            $this->snapshotStore->save(new Snapshot(
                $account->id()->toString(),
                $account->version(),
                clone $account,
                new DateTimeImmutable()
            ));
        }
    }
}
```

#### 3. Projections (Read Models)

**المفهوم:**
أنماط للقراءة مُحسَّنة ومُبنية من الأحداث.

```php
// Projection: قائمة الحسابات للعرض
class AccountListProjection {
    private Connection $readDb;
    
    public function handle(AccountOpened $event): void {
        $this->readDb->insert('account_list', [
            'id' => $event->accountId()->toString(),
            'customer_id' => $event->customerId()->toString(),
            'opened_at' => $event->occurredAt()->format('c'),
            'status' => 'active',
        ]);
    }
    
    public function handle(MoneyDeposited $event): void {
        $this->readDb->execute(
            'UPDATE account_list 
             SET balance = balance + ?,
                 last_activity = ?
             WHERE id = ?',
            [
                $event->amount()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
    
    public function handle(AccountClosed $event): void {
        $this->readDb->update('account_list',
            ['status' => 'closed', 'closed_at' => $event->occurredAt()->format('c')],
            ['id' => $event->accountId()->toString()]
        );
    }
}

// Query Handler يستخدم Projection
class GetAccountListHandler {
    private Connection $readDb;
    
    public function handle(GetAccountListQuery $query): array {
        return $this->readDb->fetchAll(
            'SELECT * FROM account_list 
             WHERE status = ? 
             ORDER BY opened_at DESC 
             LIMIT ? OFFSET ?',
            [$query->status(), $query->limit(), $query->offset()]
        );
    }
}
```

### مزايا Event Sourcing

**1. Audit Trail كامل**
كل تغيير مسجل: متى، من، ماذا.

**2. Time Travel**
إعادة النظام لأي نقطة زمنية.

**3. Debugging ممتاز**
```
"لماذا وصلنا لهذه الحالة؟"
→ قائمة الأحداث توضح كل خطوة.
```

**4. Analytics غنية**
Trends, patterns, forecasting من تاريخ الأحداث.

**5. Recovery من الفشل**
إعادة بناء الحالة من الأحداث.

### تحديات Event Sourcing

**1. التعقيد**
أكثر تعقيداً من CRUD.

**2. Learning Curve**
الفريق يحتاج للتدريب.

**3. Event Schema Evolution**
كيف تتعامل مع تغيير هيكل Events؟

```php
// الإصدار 1
class OrderCreated {
    public function __construct(
        public readonly OrderId $orderId,
        public readonly Money $total,  // في الإصدار 1 كان total فقط
    ) {}
}

// الإصدار 2: نحتاج لـ currency منفصلة
class OrderCreated {
    public function __construct(
        public readonly OrderId $orderId,
        public readonly Money $total,
        public readonly Currency $currency, // حقل جديد
    ) {}
    
    // Upgrader للأحداث القديمة
    public static function upgrade(array $oldData): self {
        return new self(
            OrderId::fromString($oldData['orderId']),
            new Money($oldData['total'], Currency::USD()), // افتراض USD للقديم
        );
    }
}
```

**4. Consistency**
الـ Read Models تكون eventually consistent.

**5. Storage**
حجم أكبر (لكن compression يُساعد).

### متى تستخدم Event Sourcing؟

**استخدمه عندما:**
- Audit trail مهم (banking, finance)
- Debugging صعب (complex domains)
- Analytics غنية مطلوبة
- Recovery مهم
- الفريق جاهز للتعقيد

**لا تستخدمه عندما:**
- نظام بسيط CRUD
- الفريق غير جاهز
- Performance critical جداً
- لا حاجة للتاريخ

---

*يتبع...*


---

## 5.3 أنماط الـ Temporal

### النمط 1: Temporal Database

**المفهوم:**
قاعدة بيانات تدعم الوقت أولاً (first-class time support).

**الأنواع:**
- **System-Time (Transaction Time):** وقت تسجيل البيانات في النظام
- **Valid-Time (Application Time):** وقت صلاحية البيانات في الواقع
- **Bitemporal:** كلاهما معاً

**التنفيذ في PostgreSQL:**
```sql
-- جدارة Bitemporal
CREATE TABLE contracts (
    id UUID PRIMARY KEY,
    customer_id UUID,
    terms TEXT,
    
    -- Valid Time: وقت صلاحية العقد
    valid_start DATE,
    valid_end DATE,
    
    -- System Time: وقت تسجيله في النظام
    sys_start TIMESTAMP GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (sys_start, sys_end)
) WITH (SYSTEM_VERSIONING = ON);

-- استعلام: ما كان ساري المفعول في 2023؟
SELECT * FROM contracts
FOR SYSTEM_TIME AS OF '2023-06-01'
WHERE valid_start <= '2023-06-01' AND valid_end > '2023-06-01';
```

**الاستخدام:**
- Financial records
- Legal documents
- Compliance

### النمط 2: CQRS (Command Query Responsibility Segregation)

**المفهوم:**
فصل أوامر الكتابة عن استعلامات القراءة.

**الهيكل:**
```
┌─────────────────┐     ┌─────────────────┐
│   Commands      │     │    Queries      │
│  (Write Side)   │     │  (Read Side)    │
│                 │     │                 │
│ Domain Model    │     │   Projections   │
│ Event Sourcing  │────▶│   Read Models   │
│                 │     │                 │
└─────────────────┘     └─────────────────┘
```

**التنفيذ:**
```php
// Command Side (Write)
class DepositMoneyCommand {
    public function __construct(
        public readonly AccountId $accountId,
        public readonly Money $amount,
        public readonly string $description
    ) {}
}

class DepositMoneyHandler {
    private AccountRepository $accounts;
    private EventBus $eventBus;
    
    public function handle(DepositMoneyCommand $command): void {
        $account = $this->accounts->find($command->accountId);
        
        $account->deposit($command->amount, $command->description);
        
        $this->accounts->save($account);
        
        // نشر الأحداث للـ Read Side
        foreach ($account->releaseEvents() as $event) {
            $this->eventBus->publish($event);
        }
    }
}

// Query Side (Read)
class AccountBalanceQuery {
    public function __construct(
        public readonly AccountId $accountId
    ) {}
}

class AccountBalanceProjection {
    private Connection $readDb;
    
    public function onMoneyDeposited(MoneyDeposited $event): void {
        $this->readDb->execute(
            'UPDATE account_balances 
             SET balance = balance + ?,
                 last_deposit = ?,
                 last_activity = ?
             WHERE account_id = ?',
            [
                $event->amount()->cents(),
                $event->amount()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
    
    public function onMoneyWithdrawn(MoneyWithdrawn $event): void {
        $this->readDb->execute(
            'UPDATE account_balances 
             SET balance = balance - ?,
                 last_withdrawal = ?,
                 last_activity = ?
             WHERE account_id = ?',
            [
                $event->amount()->cents(),
                $event->amount()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
}

class GetAccountBalanceHandler {
    private Connection $readDb;
    
    public function handle(AccountBalanceQuery $query): AccountBalanceDto {
        $row = $this->readDb->fetchOne(
            'SELECT * FROM account_balances WHERE account_id = ?',
            [$query->accountId->toString()]
        );
        
        return new AccountBalanceDto(
            accountId: $query->accountId,
            balance: Money::fromCents($row['balance'], Currency::fromCode($row['currency'])),
            lastActivity: new DateTimeImmutable($row['last_activity'])
        );
    }
}
```

**المزايا:**
- Read Models مُحسَّنة للاستعلامات
- Write Models مُحسَّنة للـ business logic
- Scale كل جانب بشكل منفصل

**التحديات:**
- Eventual consistency
- Complexity إضافي
- Synchronization challenges

### النمط 3: Saga (المعاملة الموزعة)

**المفهوم:**
إدارة معاملة (transaction) عبر multiple aggregates/services.

**الأنواع:**

**Choreography:**
كل خدمة تُكمل عملها وتُرسِل حدثاً للتالية.

**Orchestration:**
مدير مركزي (orchestrator) يُنسق الخطوات.

**التنفيذ:**
```php
// Orchestration Saga
class OrderProcessingSaga {
    private SagaStateRepository $stateRepo;
    private OrderService $orders;
    private PaymentService $payment;
    private InventoryService $inventory;
    private ShippingService $shipping;
    
    public function execute(OrderId $orderId): void {
        $saga = Saga::start('order_processing', $orderId);
        
        try {
            // الخطوة 1: معالجة الدفع
            $saga->step('payment', function() use ($orderId) {
                $order = $this->orders->find($orderId);
                return $this->payment->process($order->paymentRequest());
            });
            
            // الخطوة 2: حجز المخزون
            $saga->step('inventory', function($paymentResult) use ($orderId) {
                $order = $this->orders->find($orderId);
                return $this->inventory->reserve($order->items());
            });
            
            // الخطوة 3: إنشاء الشحنة
            $saga->step('shipping', function($inventoryResult) use ($orderId) {
                $order = $this->orders->find($orderId);
                return $this->shipping->createShipment($order);
            });
            
            $saga->complete();
            
        } catch (Exception $e) {
            $saga->compensate(); // التراجع عن الخطوات
            throw $e;
        }
    }
}

// Compensation (التراجع)
interface Compensatable {
    public function compensate(): void;
}

class PaymentStep implements Compensatable {
    private PaymentGateway $gateway;
    private TransactionId $transactionId;
    
    public function execute(): void {
        $result = $this->gateway->charge(/* ... */);
        $this->transactionId = $result->transactionId();
    }
    
    public function compensate(): void {
        if ($this->transactionId) {
            $this->gateway->refund($this->transactionId);
        }
    }
}
```

### النمط 4: Process Manager

**المفهوم:**
يدير workflow معقدة عبر الوقت.

**الفرق عن Saga:**
- Saga: معاملة واحدة (成功 أو فشل)
- Process Manager: workflow طويل المدى (قد تستمر أيام/أسابيع)

**التنفيذ:**
```php
class OrderFulfillmentProcess {
    private ProcessState $state;
    
    public function handle($event): void {
        match($this->state->currentStep()) {
            'awaiting_payment' => $this->onPaymentReceived($event),
            'awaiting_inventory' => $this->onInventoryReserved($event),
            'awaiting_shipping' => $this->onShipped($event),
            'delivered' => $this->onDelivered($event),
        };
    }
    
    private function onPaymentReceived(PaymentReceived $event): void {
        if ($event->orderId() !== $this->state->orderId()) {
            return;
        }
        
        $this->state->transitionTo('awaiting_inventory');
        $this->inventoryService->reserve($this->state->items());
    }
    
    private function onInventoryReserved(InventoryReserved $event): void {
        $this->state->transitionTo('awaiting_shipping');
        $this->shippingService->ship($this->state->orderId());
    }
    
    private function onShipped(OrderShipped $event): void {
        $this->state->transitionTo('delivered');
        $this->notificationService->notifyCustomer($this->state->customerId());
    }
}
```

### النمط 5: Deadline Pattern

**المفهوم:**
إدارة المواعيد النهائية (deadlines) في النظام.

**التنفيذ:**
```php
class PaymentDeadlineManager {
    private Scheduler $scheduler;
    private PaymentRepository $payments;
    
    public function scheduleDeadline(PaymentId $paymentId, DateTimeImmutable $deadline): void {
        $this->scheduler->schedule(
            job: new CancelPaymentIfNotCompleted($paymentId),
            at: $deadline
        );
    }
    
    public function cancelDeadline(PaymentId $paymentId): void {
        $this->scheduler->cancel("payment_deadline:{$paymentId->toString()}");
    }
}

class CancelPaymentIfNotCompleted implements Job {
    private PaymentId $paymentId;
    
    public function handle(): void {
        $payment = $this->payments->find($this->paymentId);
        
        if ($payment->status()->isPending()) {
            $payment->cancelDueToTimeout();
            $this->payments->save($payment);
        }
    }
}
```

---

## 5.4 Consistency في الزمن

### أنواع Consistency

#### 1. Strong Consistency

**المفهوم:**
جميع القراء ترى أحدث كتابة.

**التنفيذ:**
```
Write → A (تأكيد) → Read A → ترى القيمة الجديدة
```

**متى تستخدم:**
- Financial transactions
- Inventory management
- Critical business rules

#### 2. Eventual Consistency

**المفهوم:**
في النهاية جميع القراء ستترى نفس القيمة، لكن قد يكون هناك تأخير.

**التنفيذ:**
```
Write → A (async) → Read A → قد ترى القديم
                        ↓
                      بعد وقت → ترى الجديد
```

**متى تستخدم:**
- Social media feeds
- Analytics dashboards
- Non-critical read models

#### 3. Causal Consistency

**المفهوم:**
إذا حدث A قبل B، فجميع يرون A قبل B.

**التنفيذ:**
```
User writes A → then writes B
All users see A before B (or neither)
```

### إدارة Consistency في Distributed Systems

**التحدي:**
CAP Theorem: لا يمكن تحقيق Consistency + Availability + Partition Tolerance في نفس الوقت.

**الاستراتيجيات:**

**1. Two-Phase Commit (2PC)**
```
Coordinator                    Participants
     │                             │
     ├──── Prepare? ──────────────▶│
     │                             │ (write to log)
     │◀──── Yes/No ────────────────┤
     │                             │
     ├──── Commit ────────────────▶│ (if all Yes)
     │                             │ (apply changes)
     │◀──── ACK ───────────────────┤
```

**المشكلة:** Blocking, slow, coordinator single point of failure.

**2. Saga Pattern (سبق شرحه)**
Compensating transactions بدلاً من rollback.

**3. Conflict-Free Replicated Data Types (CRDTs)**
```php
// G-Counter (Grow-only Counter)
class GCounter {
    private array $values = []; // node => value
    
    public function increment(string $node): void {
        $this->values[$node] = ($this->values[$node] ?? 0) + 1;
    }
    
    public function value(): int {
        return array_sum($this->values);
    }
    
    public function merge(GCounter $other): void {
        foreach ($other->values as $node => $value) {
            $this->values[$node] = max(
                $this->values[$node] ?? 0,
                $value
            );
        }
    }
}

// الاستخدام: Counters موزعة
$node1 = new GCounter();
$node1->increment('A');
$node1->increment('A'); // value = 2

$node2 = new GCounter();
$node2->increment('B'); // value = 1

// Merge
$node1->merge($node2); // value = 3 (2 + 1)
```

**المزايا:**
- No coordination needed
- Always available
- Eventually consistent

---

## 5.5 دراسة حالة: نظام مالي زمني

### المتطلبات

**النظام:**
- إدارة حسابات بنكية
- تحويلات دولية
- تقارير تنظيمية (regulatory reporting)
- Audit trail كامل

**التحديات:**
1. لا يمكن فقدان أي معاملة
2. Audit trail مطلوب من regulators
3. Consistency قوية للـ balances
4. Performance للـ queries

### البنية

```
┌─────────────────────────────────────────────────────────────┐
│                      Frontend (Web/Mobile)                   │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                   API Gateway                                │
│        (Authentication, Rate Limiting, Routing)              │
└───────────────────────┬─────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼──────┐
│  Command     │ │   Query     │ │  Process   │
│   Service    │ │   Service   │ │  Manager   │
│   (Write)    │ │   (Read)    │ │            │
└───────┬──────┘ └──────┬──────┘ └─────┬──────┘
        │               │              │
┌───────▼───────────────▼──────────────▼──────┐
│              Event Store                     │
│         (Event Sourcing)                     │
└───────────────────────┬──────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼──────┐
│  Account     │ │ Transaction │ │  Reporting │
│ Projection   │ │  Projection │ │ Projection │
└──────────────┘ └─────────────┘ └────────────┘
```

### التنفيذ

**1. Aggregate: Account (مع Event Sourcing)**
```php
class Account {
    use EventSourcedAggregate;
    
    private AccountId $id;
    private Money $balance;
    private AccountStatus $status;
    private array $pendingTransfers = [];
    
    public static function open(AccountId $id, CustomerId $customerId, Currency $currency): self {
        return self::record(new AccountOpened($id, $customerId, $currency));
    }
    
    public function deposit(Money $amount, string $reference): void {
        $this->assertActive();
        $this->assertCurrencyMatches($amount);
        
        $this->record(new MoneyDeposited(
            accountId: $this->id,
            amount: $amount,
            reference: $reference,
            newBalance: $this->balance->add($amount)
        ));
    }
    
    public function withdraw(Money $amount, string $reference): void {
        $this->assertActive();
        $this->assertSufficientFunds($amount);
        
        $this->record(new MoneyWithdrawn(
            accountId: $this->id,
            amount: $amount,
            reference: $reference,
            newBalance: $this->balance->subtract($amount)
        ));
    }
    
    public function initiateTransfer(Money $amount, AccountId $toAccount): TransferId {
        $this->assertActive();
        $this->assertSufficientFunds($amount);
        
        $transferId = TransferId::generate();
        
        $this->record(new TransferInitiated(
            transferId: $transferId,
            fromAccount: $this->id,
            toAccount: $toAccount,
            amount: $amount
        ));
        
        return $transferId;
    }
    
    // Event handlers
    protected function applyAccountOpened(AccountOpened $event): void {
        $this->id = $event->accountId();
        $this->balance = Money::zero($event->currency());
        $this->status = AccountStatus::ACTIVE;
    }
    
    protected function applyMoneyDeposited(MoneyDeposited $event): void {
        $this->balance = $event->newBalance();
    }
    
    protected function applyMoneyWithdrawn(MoneyWithdrawn $event): void {
        $this->balance = $event->newBalance();
    }
}
```

**2. Process Manager: Transfer Processing**
```php
class TransferProcessManager {
    private TransferRepository $transfers;
    private AccountRepository $accounts;
    private ForexService $forex;
    private SwiftService $swift;
    
    public function onTransferInitiated(TransferInitiated $event): void {
        $transfer = $this->transfers->find($event->transferId());
        
        // الخطوة 1: حجز المبلغ في الحساب المصدر
        $fromAccount = $this->accounts->find($event->fromAccount());
        $fromAccount->debit($event->amount(), "Transfer {$event->transferId()}");
        $this->accounts->save($fromAccount);
        
        $transfer->markAsDebited();
        
        // الخطوة 2: إذا كانت عملة مختلفة، تحويل العملة
        if ($transfer->requiresCurrencyExchange()) {
            $rate = $this->forex->getRate(
                $transfer->sourceCurrency(),
                $transfer->targetCurrency()
            );
            $transfer->applyExchangeRate($rate);
        }
        
        // الخطوة 3: إرسال عبر SWIFT
        $swiftMessage = $this->swift->createMessage($transfer);
        $swiftRef = $this->swift->send($swiftMessage);
        
        $transfer->markAsSent($swiftRef);
        $this->transfers->save($transfer);
    }
    
    public function onSwiftConfirmation(SwiftConfirmationReceived $event): void {
        $transfer = $this->transfers->findBySwiftRef($event->swiftRef());
        
        // الخطوة 4: إيداع في الحساب المستهدف
        $toAccount = $this->accounts->find($transfer->toAccount());
        $toAccount->credit($transfer->convertedAmount(), "Transfer {$transfer->id()}");
        $this->accounts->save($toAccount);
        
        $transfer->markAsCompleted();
        $this->transfers->save($transfer);
    }
}
```

**3. Projections للقراءة**
```php
// Projection: رصيد الحساب للعرض
class AccountBalanceProjection {
    private Connection $readDb;
    
    public function onMoneyDeposited(MoneyDeposited $event): void {
        $this->readDb->execute(
            'INSERT INTO account_transactions 
             (account_id, type, amount, balance_after, reference, occurred_at)
             VALUES (?, ?, ?, ?, ?, ?)',
            [
                $event->accountId()->toString(),
                'deposit',
                $event->amount()->cents(),
                $event->newBalance()->cents(),
                $event->reference(),
                $event->occurredAt()->format('c')
            ]
        );
        
        $this->readDb->execute(
            'UPDATE account_balances 
             SET balance = ?, last_activity = ?
             WHERE account_id = ?',
            [
                $event->newBalance()->cents(),
                $event->occurredAt()->format('c'),
                $event->accountId()->toString()
            ]
        );
    }
}

// Projection: تقارير تنظيمية
class RegulatoryReportProjection {
    public function onMoneyDeposited(MoneyDeposited $event): void {
        if ($event->amount()->isGreaterThan(Money::fromDecimal(10000, 'USD'))) {
            // Large Transaction Report (للـ regulators)
            $this->readDb->insert('large_transactions', [
                'account_id' => $event->accountId()->toString(),
                'amount' => $event->amount()->cents(),
                'reference' => $event->reference(),
                'reported_at' => (new DateTimeImmutable())->format('c'),
            ]);
        }
    }
}
```

### النتائج

**قبل (Nosql تقليدي):**
- Audit trail: لا يوجد
- Debugging: صعب
- Regulatory compliance: manual

**بعد (Event Sourcing):**
- Audit trail: كامل تلقائياً
- Debugging: سهل عبر replay
- Regulatory compliance: تلقائي

---



## 5.6 التحسينات والـ Performance

### تحسين Event Store

**1. Partitioning**
```sql
-- تقسيم الأحداث حسب التاريخ
CREATE TABLE events_2024 PARTITION OF events
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE events_2025 PARTITION OF events
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**2. Indexing Strategy**
```sql
-- Index للبحث السريع
CREATE INDEX CONCURRENTLY idx_events_stream_version 
    ON events(stream_id, version);

CREATE INDEX CONCURRENTLY idx_events_occurred 
    ON events(occurred_at);

CREATE INDEX CONCURRENTLY idx_events_type 
    ON events(event_type);
```

**3. Archiving**
```php
class EventArchiver {
    public function archiveOldEvents(DateTimeImmutable $before): void {
        // نقل الأحداث القديمة لـ cold storage
        $events = $this->eventStore->readBefore($before);
        
        foreach ($events as $event) {
            $this->coldStorage->store($event);
            $this->eventStore->markAsArchived($event->id());
        }
    }
}
```

### Caching Strategies

**1. Snapshot Caching**
```php
class CachedSnapshotStore implements SnapshotStore {
    private SnapshotStore $inner;
    private Cache $cache;
    
    public function getLatest(string $streamId): ?Snapshot {
        $key = "snapshot:{$streamId}";
        
        $cached = $this->cache->get($key);
        if ($cached) {
            return $cached;
        }
        
        $snapshot = $this->inner->getLatest($streamId);
        if ($snapshot) {
            $this->cache->set($key, $snapshot, 3600); // 1 hour
        }
        
        return $snapshot;
    }
}
```

**2. Projection Caching**
```php
class CachedAccountBalanceProjection {
    private AccountBalanceProjection $inner;
    private Cache $cache;
    
    public function getBalance(AccountId $id): Money {
        $key = "balance:{$id->toString()}";
        
        $cached = $this->cache->get($key);
        if ($cached) {
            return Money::fromCents($cached['amount'], Currency::fromCode($cached['currency']));
        }
        
        $balance = $this->inner->getBalance($id);
        
        $this->cache->set($key, [
            'amount' => $balance->cents(),
            'currency' => $balance->currency()->code()
        ], 60); // 1 minute
        
        return $balance;
    }
    
    public function onMoneyDeposited(MoneyDeposited $event): void {
        $this->inner->onMoneyDeposited($event);
        
        // Invalidate cache
        $this->cache->delete("balance:{$event->accountId()->toString()}");
    }
}
```

### Batch Processing

**لـ Projections:**
```php
class BatchProjection {
    private Connection $db;
    private array $buffer = [];
    private int $batchSize = 100;
    
    public function handle(DomainEvent $event): void {
        $this->buffer[] = $this->transform($event);
        
        if (count($this->buffer) >= $this->batchSize) {
            $this->flush();
        }
    }
    
    public function flush(): void {
        if (empty($this->buffer)) {
            return;
        }
        
        $this->db->transactional(function() {
            foreach ($this->buffer as $record) {
                $this->db->insert('projection_table', $record);
            }
        });
        
        $this->buffer = [];
    }
}
```

---

## 5.7 Testing في الأنظمة الزمنية

### Testing Event Sourced Aggregates

**1. Given-When-Then**
```php
class AccountTest extends TestCase {
    use EventSourcedAggregateTestCase;
    
    public function testCanDepositMoney(): void {
        $this->given(
            new AccountOpened(AccountId::generate(), CustomerId::generate(), Currency::USD())
        )
        ->when(fn(Account $account) => $account->deposit(Money::fromDecimal(100, 'USD'), 'Salary'))
        ->then(
            new MoneyDeposited(/* ... */)
        );
    }
    
    public function testCannotWithdrawMoreThanBalance(): void {
        $this->given(
            new AccountOpened(AccountId::generate(), CustomerId::generate(), Currency::USD()),
            new MoneyDeposited(/* ... 50 USD */)
        )
        ->when(fn(Account $account) => $account->withdraw(Money::fromDecimal(100, 'USD'), 'Purchase'))
        ->expectException(InsufficientFundsException::class);
    }
}
```

**2. Time Travel Testing**
```php
class TimeTravelTest extends TestCase {
    public function testAccountStateAtSpecificTime(): void {
        $account = Account::open(AccountId::generate(), CustomerId::generate(), Currency::USD());
        
        // T1
        Clock::freeze(new DateTimeImmutable('2024-01-01'));
        $account->deposit(Money::fromDecimal(100, 'USD'), 'Deposit 1');
        
        // T2
        Clock::freeze(new DateTimeImmutable('2024-02-01'));
        $account->withdraw(Money::fromDecimal(30, 'USD'), 'Withdrawal 1');
        
        // T3
        Clock::freeze(new DateTimeImmutable('2024-03-01'));
        $account->deposit(Money::fromDecimal(50, 'USD'), 'Deposit 2');
        
        // Test: ما كان الرصيد في 15 يناير؟
        $stateAtJan15 = $account->stateAt(new DateTimeImmutable('2024-01-15'));
        $this->assertEquals(Money::fromDecimal(100, 'USD'), $stateAtJan15->balance());
        
        // Test: ما كان الرصيد في 15 فبراير؟
        $stateAtFeb15 = $account->stateAt(new DateTimeImmutable('2024-02-15'));
        $this->assertEquals(Money::fromDecimal(70, 'USD'), $stateAtFeb15->balance());
    }
}
```

### Testing Sagas

```php
class OrderProcessingSagaTest extends TestCase {
    use SagaTestCase;
    
    public function testSuccessfulOrderProcessing(): void {
        $saga = $this->startSaga(OrderProcessingSaga::class);
        
        // الخطوة 1
        $saga->handle(new OrderCreated(/* ... */));
        $this->assertDispatched(ReserveInventory::class);
        
        // الخطوة 2
        $saga->handle(new InventoryReserved(/* ... */));
        $this->assertDispatched(ProcessPayment::class);
        
        // الخطوة 3
        $saga->handle(new PaymentProcessed(/* ... */));
        $this->assertDispatched(CreateShipment::class);
        
        // الخطوة 4
        $saga->handle(new ShipmentCreated(/* ... */));
        $this->assertSagaCompleted();
    }
    
    public function testCompensationOnFailure(): void {
        $saga = $this->startSaga(OrderProcessingSaga::class);
        
        $saga->handle(new OrderCreated(/* ... */));
        $saga->handle(new InventoryReserved(/* ... */));
        
        // فشل الدفع
        $saga->handle(new PaymentFailed(/* ... */));
        
        // يجب التعويض
        $this->assertDispatched(ReleaseInventory::class);
        $this->assertSagaFailed();
    }
}
```

---

## 5.8 Anti-patterns الزمنية

### 1. Event Sourcing كل شيء

**المشكلة:**
استخدام Event Sourcing حتى للبيانات البسيطة.

**الحل:**
استخدم Event Sourcing للـ Aggregates المعقدة فقط.
استخدم CRUD للبيانات البسيطة.

### 2. Events بدون Schema

**المشكلة:**
JSON غير منظم يصعب التطوير.

**الحل:**
استخدم Typed Events مع versioning.

### 3. Projection سريع جداً

**المشكلة:**
تحديث projections بشكل متزامن يؤدي لـ latency.

**الحل:**
Async projections مع tolerance للـ eventual consistency.

### 4. ignoring Time Zones

**المشكلة:**
تخزين وقت بدون timezone.

**الحل:**
دائماً استخدم UTC في التخزين، وconvert للعرض.

### 5. Large Aggregates

**المشكلة:**
Aggregate واحد يحتوي على آلاف الأحداث.

**الحل:**
استخدم Snapshotting أو قسّم Aggregate.

---

## خاتمة الفصل الخامس

### ما تعلمناه

**الأساسيات:**
- الزمن كبعد معماري رابع
- الفرق بين النماذج الآنية والزمنية
- Event كوحدة زمنية أساسية

**Event Sourcing:**
- Source of truth هو تاريخ الأحداث
- Snapshots للأداء
- Projections للقراءة

**الأنماط:**
- Temporal Database
- CQRS
- Saga Pattern
- Process Manager
- Deadline Pattern

**Consistency:**
- Strong vs Eventual
- 2PC, Saga, CRDTs
- Trade-offs ومتى تستخدم كل واحد

**التطبيق العملي:**
- دراسة حالة نظام مالي
- Testing strategies
- Performance optimizations
- Anti-patterns

### متى تبني نظاماً زمنياً؟

**ابنِ نظاماً زمنياً عندما:**
- Audit trail مهم
- Debugging معقد
- تحليل تاريخي مطلوب
- Recovery مهم

**لا تبنِ نظاماً زمنياً عندما:**
- البيانات بسيطة وثابتة
- Performance أولوية قصوى
- الفريق غير جاهز
- الـ use case واضح ولا يحتاج تاريخ

### إلى الأمام

في الفصول القادمة، سنستكشف:
- **الفصل السادس:** الأثر الصامت (Side Effects)
- **الفصل السابع:** معمارية المؤسسة
- **الفصل الثامن:** الأمن السيادي

---

**© 2025 محمد العبيد | المعماري**

*"السيادة الحقيقية على حرفتك"*

**نهاية الفصل الخامس - السيادة الزمنية**

---



---

## 5.9 الـ Event Store في الإنتاج

### بناء Event Store من الصفر

**المتطلبات:**
1. **Ordering:** تسلسل صارم للأحداث
2. **Concurrency Control:** التعامل مع الكتابات المتزامنة
3. **Scalability:** القدرة على التوسع
4. **Reliability:** عدم فقدان الأحداث
5. **Queryability:** البحث السريع

**التصميم:**

#### 1. Database Schema

```sql
-- الجدول الرئيسي للأحداث
CREATE TABLE event_streams (
    stream_id VARCHAR(255) NOT NULL,
    stream_type VARCHAR(255) NOT NULL,  -- 'order', 'customer', etc.
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    metadata JSONB,  -- بيانات وصفية للـ stream
    PRIMARY KEY (stream_id)
);

-- الجدول الفرعي للأحداث
CREATE TABLE events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    stream_id VARCHAR(255) NOT NULL REFERENCES event_streams(stream_id),
    version INTEGER NOT NULL,  -- رقم الإصدار ضمن الـ stream
    event_type VARCHAR(500) NOT NULL,  -- FQCN
    payload JSONB NOT NULL,  -- بيانات الحدث
    metadata JSONB NOT NULL DEFAULT '{}',  -- بيانات وصفية
    occurred_at TIMESTAMP NOT NULL,  -- وقت حدوث الحدث (business time)
    recorded_at TIMESTAMP NOT NULL DEFAULT NOW(),  -- وقت التسجيل (system time)
    correlation_id UUID,  -- لـ distributed tracing
    causation_id UUID,    -- الحدث الذي أدى لهذا
    
    -- Constraint فريد للتأكد من عدم وجود conflict
    UNIQUE (stream_id, version)
);

-- Indexes للبحث السريع
CREATE INDEX idx_events_stream_version ON events(stream_id, version);
CREATE INDEX idx_events_type ON events(event_type);
CREATE INDEX idx_events_occurred ON events(occurred_at);
CREATE INDEX idx_events_correlation ON events(correlation_id);

-- Partitioning حسب الوقت
CREATE TABLE events_2024q1 PARTITION OF events
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE events_2024q2 PARTITION OF events
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');
```

#### 2. Optimistic Concurrency Control

```php
final class OptimisticConcurrencyControl {
    private Connection $db;
    
    /**
     * @throws ConcurrencyException
     */
    public function appendEvents(
        string $streamId,
        int $expectedVersion,
        array $events,
        callable $onConflict = null
    ): void {
        $this->db->transactional(function() use (
            $streamId, 
            $expectedVersion, 
            $events,
            $onConflict
        ) {
            // 1. التحقق من الإصدار الحالي
            $currentVersion = $this->getCurrentVersion($streamId);
            
            if ($currentVersion !== $expectedVersion) {
                if ($onConflict) {
                    return $onConflict($currentVersion, $expectedVersion);
                }
                
                throw new ConcurrencyException(
                    "Stream {$streamId}: expected version {$expectedVersion}, " .
                    "but found {$currentVersion}"
                );
            }
            
            // 2. إدراج الأحداث
            foreach ($events as $index => $event) {
                $this->insertEvent(
                    $streamId,
                    $expectedVersion + $index + 1,
                    $event
                );
            }
            
            // 3. تحديث إصدار الـ stream
            $this->updateStreamVersion($streamId, $expectedVersion + count($events));
        });
    }
    
    private function getCurrentVersion(string $streamId): int {
        $result = $this->db->fetchOne(
            'SELECT MAX(version) FROM events WHERE stream_id = ?',
            [$streamId]
        );
        
        return $result ? (int) $result : 0;
    }
    
    private function insertEvent(
        string $streamId, 
        int $version, 
        DomainEvent $event
    ): void {
        $this->db->insert('events', [
            'stream_id' => $streamId,
            'version' => $version,
            'event_type' => get_class($event),
            'payload' => json_encode($this->serializer->serialize($event)),
            'metadata' => json_encode([
                'user_id' => $event->userId()?->toString(),
                'ip_address' => $event->ipAddress(),
            ]),
            'occurred_at' => $event->occurredAt()->format('c'),
            'correlation_id' => $event->correlationId()?->toString(),
            'causation_id' => $event->causationId()?->toString(),
        ]);
    }
}
```

#### 3. Event Store Interface

```php
interface EventStore {
    /**
     * إلحاق أحداث جديدة بـ stream
     * 
     * @param string $streamId معرف الـ stream
     * @param int $expectedVersion الإصدار المتوقع (للـ optimistic concurrency)
     * @param DomainEvent[] $events الأحداث المراد إضافتها
     * @throws ConcurrencyException إذا كان الإصدار غير متطابق
     */
    public function append(
        string $streamId,
        int $expectedVersion,
        array $events
    ): void;
    
    /**
     * قراءة جميع أحداث stream
     */
    public function readStream(string $streamId): EventStream;
    
    /**
     * قراءة من إصدار محدد
     */
    public function readFromVersion(string $streamId, int $version): EventStream;
    
    /**
     * قراءة الأحداث في نطاق زمني
     */
    public function readInTimeRange(
        string $streamId,
        DateTimeImmutable $from,
        DateTimeImmutable $to
    ): EventStream;
    
    /**
     * الاشتراك في أحداث stream (للـ real-time processing)
     */
    public function subscribe(string $streamId, callable $handler): Subscription;
}

// تنفيذ PostgreSQL
final class PostgreSqlEventStore implements EventStore {
    public function __construct(
        private Connection $connection,
        private EventSerializer $serializer,
        private EventBus $eventBus,
        private LoggerInterface $logger
    ) {}
    
    public function append(
        string $streamId,
        int $expectedVersion,
        array $events
    ): void {
        $this->connection->transactional(function() use (
            $streamId,
            $expectedVersion,
            $events
        ) {
            // التحقق من التفاؤلية في التزامن
            $currentVersion = $this->getCurrentVersion($streamId);
            
            if ($currentVersion !== $expectedVersion) {
                $this->logger->warning('Concurrency conflict detected', [
                    'stream_id' => $streamId,
                    'expected_version' => $expectedVersion,
                    'actual_version' => $currentVersion,
                ]);
                
                throw new ConcurrencyException(
                    "Stream {$streamId}: expected version {$expectedVersion}, " .
                    "but found {$currentVersion}. " .
                    "The stream has been modified by another process."
                );
            }
            
            // إدراج الأحداث
            foreach ($events as $index => $event) {
                $this->insertEvent(
                    $streamId,
                    $expectedVersion + $index + 1,
                    $event
                );
            }
            
            // نشر الأحداث (للـ projections)
            foreach ($events as $event) {
                $this->eventBus->publish($event);
            }
        });
    }
    
    public function readStream(string $streamId): EventStream {
        $rows = $this->connection->fetchAll(
            'SELECT * FROM events 
             WHERE stream_id = ? 
             ORDER BY version ASC',
            [$streamId]
        );
        
        return $this->mapToEventStream($rows);
    }
    
    public function readFromVersion(string $streamId, int $version): EventStream {
        $rows = $this->connection->fetchAll(
            'SELECT * FROM events 
             WHERE stream_id = ? AND version >= ?
             ORDER BY version ASC',
            [$streamId, $version]
        );
        
        return $this->mapToEventStream($rows);
    }
    
    public function readInTimeRange(
        string $streamId,
        DateTimeImmutable $from,
        DateTimeImmutable $to
    ): EventStream {
        $rows = $this->connection->fetchAll(
            'SELECT * FROM events 
             WHERE stream_id = ? 
               AND occurred_at >= ? 
               AND occurred_at < ?
             ORDER BY occurred_at ASC, version ASC',
            [
                $streamId,
                $from->format('c'),
                $to->format('c'),
            ]
        );
        
        return $this->mapToEventStream($rows);
    }
    
    public function subscribe(string $streamId, callable $handler): Subscription {
        return $this->eventBus->subscribe($streamId, $handler);
    }
    
    private function mapToEventStream(array $rows): EventStream {
        $events = array_map(
            fn($row) => $this->serializer->deserialize(
                $row['event_type'],
                json_decode($row['payload'], true)
            ),
            $rows
        );
        
        return new EventStream($events);
    }
}
```

### Performance Optimizations

#### 1. Snapshotting

```php
interface SnapshotStore {
    public function save(Snapshot $snapshot): void;
    public function getLatest(string $streamId): ?Snapshot;
    public function getAtVersion(string $streamId, int $version): ?Snapshot;
}

final class PostgreSqlSnapshotStore implements SnapshotStore {
    public function __construct(
        private Connection $connection,
        private Serializer $serializer
    ) {}
    
    public function save(Snapshot $snapshot): void {
        $this->connection->upsert('snapshots', [
            'stream_id' => $snapshot->streamId(),
            'version' => $snapshot->version(),
            'state' => $this->serializer->serialize($snapshot->state()),
            'created_at' => $snapshot->createdAt()->format('c'),
        ], ['stream_id', 'version']);
    }
    
    public function getLatest(string $streamId): ?Snapshot {
        $row = $this->connection->fetchOne(
            'SELECT * FROM snapshots 
             WHERE stream_id = ? 
             ORDER BY version DESC 
             LIMIT 1',
            [$streamId]
        );
        
        if (!$row) {
            return null;
        }
        
        return $this->mapToSnapshot($row);
    }
    
    public function getAtVersion(string $streamId, int $version): ?Snapshot {
        $row = $this->connection->fetchOne(
            'SELECT * FROM snapshots 
             WHERE stream_id = ? AND version <= ?
             ORDER BY version DESC 
             LIMIT 1',
            [$streamId, $version]
        );
        
        if (!$row) {
            return null;
        }
        
        return $this->mapToSnapshot($row);
    }
}

// Repository مع Snapshotting
class SnapshottingRepository {
    public function __construct(
        private EventStore $eventStore,
        private SnapshotStore $snapshotStore,
        private int $snapshotFrequency = 100  // كل 100 حدث
    ) {}
    
    public function find(AggregateId $id): ?Aggregate {
        $streamId = $id->toString();
        
        // 1. محاولة الحصول على snapshot
        $snapshot = $this->snapshotStore->getLatest($streamId);
        
        if ($snapshot) {
            // إعادة بناء من snapshot
            $aggregate = $snapshot->state();
            $fromVersion = $snapshot->version() + 1;
        } else {
            // إعادة بناء من الصفر
            $aggregate = new Aggregate();
            $fromVersion = 1;
        }
        
        // 2. قراءة الأحداث اللاحقة
        $events = $this->eventStore->readFromVersion($streamId, $fromVersion);
        
        // 3. تطبيق الأحداث
        foreach ($events as $event) {
            $aggregate->apply($event);
        }
        
        return $aggregate;
    }
    
    public function save(Aggregate $aggregate): void {
        $streamId = $aggregate->id()->toString();
        $events = $aggregate->releaseEvents();
        $currentVersion = $aggregate->version();
        
        if (empty($events)) {
            return;  // لا شيء للحفظ
        }
        
        // حفظ الأحداث
        $this->eventStore->append(
            $streamId,
            $currentVersion - count($events),
            $events
        );
        
        // إنشاء snapshot إذا لزم
        if ($currentVersion % $this->snapshotFrequency === 0) {
            $this->snapshotStore->save(new Snapshot(
                $streamId,
                $currentVersion,
                clone $aggregate,
                new DateTimeImmutable()
            ));
        }
    }
}
```

#### 2. Caching

```php
class CachedEventStore implements EventStore {
    public function __construct(
        private EventStore $inner,
        private Cache $cache,
        private int $ttl = 300  // 5 minutes
    ) {}
    
    public function readStream(string $streamId): EventStream {
        $cacheKey = "event_stream:{$streamId}";
        
        $cached = $this->cache->get($cacheKey);
        if ($cached) {
            return EventStream::fromArray($cached);
        }
        
        $stream = $this->inner->readStream($streamId);
        
        // تخزين في cache (فقط إذا كان stream صغيراً)
        if ($stream->count() < 1000) {
            $this->cache->set($cacheKey, $stream->toArray(), $this->ttl);
        }
        
        return $stream;
    }
    
    public function append(string $streamId, int $expectedVersion, array $events): void {
        $this->inner->append($streamId, $expectedVersion, $events);
        
        // إبطال cache
        $this->cache->delete("event_stream:{$streamId}");
    }
}
```

#### 3. Async Processing

```php
// Publisher للـ projections
class AsyncEventPublisher {
    public function __construct(
        private MessageQueue $queue,
        private EventSerializer $serializer
    ) {}
    
    public function publish(array $events): void {
        foreach ($events as $event) {
            $this->queue->publish(
                exchange: 'events',
                routingKey: $this->getRoutingKey($event),
                message: [
                    'type' => get_class($event),
                    'payload' => $this->serializer->serialize($event),
                    'metadata' => [
                        'occurred_at' => $event->occurredAt()->format('c'),
                        'stream_id' => $event->streamId(),
                    ],
                ]
            );
        }
    }
    
    private function getRoutingKey(DomainEvent $event): string {
        // routing حسب النوع
        return str_replace('\\', '.', get_class($event));
    }
}

// Consumer للـ projections
class ProjectionConsumer {
    public function __construct(
        private ProjectionManager $projections,
        private EventSerializer $serializer,
        private DeadLetterQueue $dlq
    ) {}
    
    public function consume(Message $message): void {
        try {
            $event = $this->serializer->deserialize(
                $message['type'],
                $message['payload']
            );
            
            $this->projections->handle($event);
            
        } catch (Exception $e) {
            // إرسال لـ Dead Letter Queue
            $this->dlq->send($message, [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
        }
    }
}
```

---



## 5.10 دراسة حالة: E-commerce Platform كامل

### نظرة عامة على النظام

**المكونات:**
- **Product Catalog:** إدارة المنتجات
- **Shopping Cart:** سلة التسوق
- **Order Management:** إدارة الطلبات
- **Inventory:** إدارة المخزون
- **Payment:** معالجة الدفع
- **Shipping:** الشحن والتوصيل
- **Customer:** إدارة العملاء

**التحدي:**
كيف نضمن Consistency بين هذه المكونات دون coupling قوي؟

### البنية المعمارية

```
┌──────────────────────────────────────────────────────────────┐
│                     API Gateway                               │
└──────────────┬───────────────────────────────────────────────┘
               │
       ┌───────┴───────┐
       │               │
┌──────▼──────┐  ┌─────▼──────┐
│   Command   │  │   Query    │
│   Service   │  │   Service  │
└──────┬──────┘  └─────┬──────┘
       │               │
       └───────┬───────┘
               │
        ┌──────▼──────┐
        │  Event Bus  │
        └──────┬──────┘
               │
    ┌──────────┼──────────┐
    │          │          │
┌───▼───┐ ┌────▼───┐ ┌────▼────┐
│Product│ │ Order  │ │Inventory│
│Service│ │Service │ │ Service │
└───┬───┘ └────┬───┘ └────┬────┘
    │          │          │
    └──────────┴──────────┘
               │
        ┌──────▼──────┐
        │ Event Store │
        └─────────────┘
```

### Product Catalog

**Aggregate: Product**
```php
class Product {
    private ProductId $id;
    private string $name;
    private string $description;
    private Money $price;
    private int $stockQuantity;
    private ProductStatus $status;
    
    public static function create(
        ProductId $id,
        string $name,
        Money $price,
        int $initialStock
    ): self {
        $product = new self();
        $product->record(new ProductCreated($id, $name, $price, $initialStock));
        return $product;
    }
    
    public function updatePrice(Money $newPrice): void {
        if ($this->price->equals($newPrice)) {
            return;
        }
        
        $this->record(new ProductPriceUpdated(
            $this->id,
            $oldPrice: $this->price,
            $newPrice: $newPrice
        ));
    }
    
    public function reserveStock(int $quantity): void {
        if ($quantity > $this->stockQuantity) {
            throw new InsufficientStockException();
        }
        
        $this->record(new StockReserved(
            $this->id,
            $quantity,
            $this->stockQuantity - $quantity
        ));
    }
    
    public function releaseStock(int $quantity): void {
        $this->record(new StockReleased(
            $this->id,
            $quantity,
            $this->stockQuantity + $quantity
        ));
    }
    
    protected function applyProductCreated(ProductCreated $event): void {
        $this->id = $event->productId();
        $this->name = $event->name();
        $this->price = $event->price();
        $this->stockQuantity = $event->initialStock();
        $this->status = ProductStatus::ACTIVE();
    }
    
    protected function applyProductPriceUpdated(ProductPriceUpdated $event): void {
        $this->price = $event->newPrice();
    }
    
    protected function applyStockReserved(StockReserved $event): void {
        $this->stockQuantity = $event->newQuantity();
    }
    
    protected function applyStockReleased(StockReleased $event): void {
        $this->stockQuantity = $event->newQuantity();
    }
}
```

### Shopping Cart

**Cart as Temporal Object:**
```php
class ShoppingCart {
    private CartId $id;
    private CustomerId $customerId;
    private array $items = [];  // CartItem[]
    private ?DateTimeImmutable $checkedOutAt = null;
    
    public static function create(CartId $id, CustomerId $customerId): self {
        $cart = new self();
        $cart->record(new CartCreated($id, $customerId));
        return $cart;
    }
    
    public function addItem(ProductId $productId, int $quantity, Money $unitPrice): void {
        if ($this->isCheckedOut()) {
            throw new CartAlreadyCheckedOutException();
        }
        
        $existingItem = $this->findItem($productId);
        
        if ($existingItem) {
            // تحديث الكمية
            $newQuantity = $existingItem->quantity() + $quantity;
            $this->record(new CartItemQuantityUpdated(
                $this->id,
                $productId,
                $newQuantity
            ));
        } else {
            // إضافة عنصر جديد
            $this->record(new CartItemAdded(
                $this->id,
                $productId,
                $quantity,
                $unitPrice
            ));
        }
    }
    
    public function removeItem(ProductId $productId): void {
        if (!$this->findItem($productId)) {
            return;
        }
        
        $this->record(new CartItemRemoved($this->id, $productId));
    }
    
    public function checkout(): OrderId {
        if ($this->isCheckedOut()) {
            throw new CartAlreadyCheckedOutException();
        }
        
        if (empty($this->items)) {
            throw new EmptyCartException();
        }
        
        $orderId = OrderId::generate();
        
        $this->record(new CartCheckedOut(
            $this->id,
            $orderId,
            $this->items,
            $this->total()
        ));
        
        return $orderId;
    }
    
    public function isCheckedOut(): bool {
        return $this->checkedOutAt !== null;
    }
    
    public function total(): Money {
        return array_reduce(
            $this->items,
            fn(Money $total, CartItem $item) => $total->add($item->subtotal()),
            Money::zero($this->currency())
        );
    }
}
```

### Order Process Manager

**Coordinator لـ Order Lifecycle:**
```php
class OrderFulfillmentProcess {
    private ProcessState $state;
    private EventBus $eventBus;
    
    public function handle(DomainEvent $event): void {
        match($this->state->status()) {
            OrderStatus::PENDING => $this->handlePending($event),
            OrderStatus::AWAITING_PAYMENT => $this->handleAwaitingPayment($event),
            OrderStatus::PAYMENT_CONFIRMED => $this->handlePaymentConfirmed($event),
            OrderStatus::AWAITING_INVENTORY => $this->handleAwaitingInventory($event),
            OrderStatus::READY_FOR_SHIPPING => $this->handleReadyForShipping($event),
            OrderStatus::SHIPPED => $this->handleShipped($event),
            OrderStatus::DELIVERED => $this->handleDelivered($event),
        };
    }
    
    private function handlePending(DomainEvent $event): void {
        if ($event instanceof OrderCreated) {
            // الخطوة 1: حجز المخزون
            $this->eventBus->publish(new ReserveInventory(
                orderId: $event->orderId(),
                items: $event->items()
            ));
            
            $this->state->transitionTo(OrderStatus::AWAITING_INVENTORY);
        }
    }
    
    private function handleAwaitingInventory(DomainEvent $event): void {
        if ($event instanceof InventoryReserved) {
            // الخطوة 2: معالجة الدفع
            $this->eventBus->publish(new ProcessPayment(
                orderId: $event->orderId(),
                amount: $this->state->total()
            ));
            
            $this->state->transitionTo(OrderStatus::AWAITING_PAYMENT);
            
        } elseif ($event instanceof InventoryReservationFailed) {
            // فشل: إلغاء الطلب
            $this->cancelOrder('Insufficient inventory');
        }
    }
    
    private function handleAwaitingPayment(DomainEvent $event): void {
        if ($event instanceof PaymentProcessed) {
            // الخطوة 3: إنشاء الشحنة
            $this->eventBus->publish(new CreateShipment(
                orderId: $event->orderId(),
                address: $this->state->shippingAddress()
            ));
            
            $this->state->transitionTo(OrderStatus::READY_FOR_SHIPPING);
            
        } elseif ($event instanceof PaymentFailed) {
            // فشل: تحرير المخزون وإلغاء
            $this->eventBus->publish(new ReleaseInventory(
                orderId: $this->state->orderId(),
                items: $this->state->items()
            ));
            
            $this->cancelOrder('Payment failed');
        }
    }
    
    private function handleReadyForShipping(DomainEvent $event): void {
        if ($event instanceof ShipmentCreated) {
            $this->state->transitionTo(OrderStatus::SHIPPED);
            
            // إشعار العميل
            $this->eventBus->publish(new NotifyCustomer(
                customerId: $this->state->customerId(),
                message: "Your order has been shipped! Tracking: {$event->trackingNumber()}"
            ));
        }
    }
    
    private function handleShipped(DomainEvent $event): void {
        if ($event instanceof DeliveryConfirmed) {
            $this->state->transitionTo(OrderStatus::DELIVERED);
            
            // إغلاق الطلب
            $this->eventBus->publish(new CompleteOrder(
                orderId: $this->state->orderId()
            ));
        }
    }
    
    private function cancelOrder(string $reason): void {
        $this->state->transitionTo(OrderStatus::CANCELLED);
        
        $this->eventBus->publish(new OrderCancelled(
            orderId: $this->state->orderId(),
            reason: $reason
        ));
    }
}
```

### Inventory Saga

**Distributed Transaction:**
```php
class InventoryReservationSaga {
    private SagaState $state;
    
    public function execute(ReserveInventoryCommand $command): void {
        $items = $command->items();
        $reservedItems = [];
        
        try {
            foreach ($items as $item) {
                // محاولة حجز كل منتج
                $product = $this->productRepository->find($item->productId());
                
                if (!$product->hasSufficientStock($item->quantity())) {
                    throw new InsufficientStockException($product->id());
                }
                
                $product->reserveStock($item->quantity());
                $this->productRepository->save($product);
                
                $reservedItems[] = $item;
            }
            
            // نجاح: إشعار بالنجاح
            $this->eventBus->publish(new InventoryReserved(
                orderId: $command->orderId(),
                items: $reservedItems
            ));
            
        } catch (InsufficientStockException $e) {
            // فشل: تحرير ما تم حجزه
            foreach ($reservedItems as $reservedItem) {
                $product = $this->productRepository->find($reservedItem->productId());
                $product->releaseStock($reservedItem->quantity());
                $this->productRepository->save($product);
            }
            
            $this->eventBus->publish(new InventoryReservationFailed(
                orderId: $command->orderId(),
                failedProductId: $e->productId()
            ));
        }
    }
}
```

### Projections للـ Read Models

**Product Catalog Projection:**
```php
class ProductCatalogProjection {
    private Connection $readDb;
    
    public function onProductCreated(ProductCreated $event): void {
        $this->readDb->insert('product_catalog', [
            'product_id' => $event->productId()->toString(),
            'name' => $event->name(),
            'description' => $event->description(),
            'price_amount' => $event->price()->cents(),
            'price_currency' => $event->price()->currency()->code(),
            'available_stock' => $event->initialStock(),
            'status' => 'active',
            'created_at' => $event->occurredAt()->format('c'),
        ]);
    }
    
    public function onProductPriceUpdated(ProductPriceUpdated $event): void {
        $this->readDb->update('product_catalog',
            [
                'price_amount' => $event->newPrice()->cents(),
                'price_currency' => $event->newPrice()->currency()->code(),
                'price_updated_at' => $event->occurredAt()->format('c'),
            ],
            ['product_id' => $event->productId()->toString()]
        );
    }
    
    public function onStockReserved(StockReserved $event): void {
        $this->readDb->execute(
            'UPDATE product_catalog 
             SET available_stock = available_stock - ?,
                 reserved_stock = reserved_stock + ?
             WHERE product_id = ?',
            [
                $event->quantity(),
                $event->quantity(),
                $event->productId()->toString()
            ]
        );
    }
    
    public function onStockReleased(StockReleased $event): void {
        $this->readDb->execute(
            'UPDATE product_catalog 
             SET available_stock = available_stock + ?,
                 reserved_stock = reserved_stock - ?
             WHERE product_id = ?',
            [
                $event->quantity(),
                $event->quantity(),
                $event->productId()->toString()
            ]
        );
    }
}

// Order History Projection
class OrderHistoryProjection {
    private Connection $readDb;
    
    public function onOrderCreated(OrderCreated $event): void {
        $this->readDb->insert('order_history', [
            'order_id' => $event->orderId()->toString(),
            'customer_id' => $event->customerId()->toString(),
            'status' => 'pending',
            'total_amount' => $event->total()->cents(),
            'total_currency' => $event->total()->currency()->code(),
            'item_count' => count($event->items()),
            'created_at' => $event->occurredAt()->format('c'),
        ]);
        
        // تفاصيل العناصر
        foreach ($event->items() as $item) {
            $this->readDb->insert('order_items', [
                'order_id' => $event->orderId()->toString(),
                'product_id' => $item->productId()->toString(),
                'product_name' => $item->productName(),
                'quantity' => $item->quantity(),
                'unit_price' => $item->unitPrice()->cents(),
                'subtotal' => $item->subtotal()->cents(),
            ]);
        }
    }
    
    public function onOrderStatusChanged(OrderStatusChanged $event): void {
        $this->readDb->update('order_history',
            [
                'status' => $event->newStatus()->value(),
                'status_changed_at' => $event->occurredAt()->format('c'),
            ],
            ['order_id' => $event->orderId()->toString()]
        );
        
        // تسجيل التغيير في history
        $this->readDb->insert('order_status_history', [
            'order_id' => $event->orderId()->toString(),
            'from_status' => $event->oldStatus()->value(),
            'to_status' => $event->newStatus()->value(),
            'changed_at' => $event->occurredAt()->format('c'),
            'reason' => $event->reason(),
        ]);
    }
}
```

### Testing End-to-End

**Integration Test:**
```php
class OrderFulfillmentTest extends IntegrationTestCase {
    public function testCompleteOrderFlow(): void {
        // 1. إنشاء منتج
        $product = Product::create(
            ProductId::generate(),
            'Test Product',
            Money::fromDecimal(100, 'USD'),
            10
        );
        $this->productRepository->save($product);
        
        // 2. إنشاء سلة
        $cart = ShoppingCart::create(CartId::generate(), CustomerId::generate());
        $cart->addItem($product->id(), 2, $product->price());
        $this->cartRepository->save($cart);
        
        // 3. إتمام الشراء
        $orderId = $cart->checkout();
        $this->cartRepository->save($cart);
        
        // 4. انتظار معالجة Order
        $this->eventBus->dispatchQueuedEvents();
        
        // 5. التحقق من حجز المخزون
        $updatedProduct = $this->productRepository->find($product->id());
        $this->assertEquals(8, $updatedProduct->availableStock());
        
        // 6. محاكاة الدفع الناجح
        $this->eventBus->publish(new PaymentProcessed(
            orderId: $orderId,
            transactionId: TransactionId::generate()
        ));
        
        // 7. التحقق من إنشاء الشحنة
        $order = $this->orderRepository->find($orderId);
        $this->assertTrue($order->status()->isReadyForShipping());
    }
}
```

---



## 5.11 Migration إلى Event Sourcing

### استراتيجيات الـ Migration

#### 1. Big Bang Migration

**متى تستخدم:**
- نظام صغير
- فترة صيانة متاحة
- فريق متمرس

**الخطوات:**
```php
// 1. إيقاف النظام
// 2. تصدير البيانات
// 3. تحويلها لأحداث
// 4. استيرادها في Event Store
// 5. تشغيل النظام الجديد

class LegacyDataMigrator {
    public function migrate(): void {
        $legacyOrders = $this->legacyDb->fetchAll('SELECT * FROM orders');
        
        foreach ($legacyOrders as $legacyOrder) {
            // إنشاء أحداث من الحالة القديمة
            $events = $this->reconstructEvents($legacyOrder);
            
            // حفظ في Event Store
            $this->eventStore->append(
                "order:{$legacyOrder['id']}",
                0,  // expected version for new stream
                $events
            );
        }
    }
    
    private function reconstructEvents(array $legacyOrder): array {
        $events = [];
        
        // حدث الإنشاء
        $events[] = new OrderCreated(
            OrderId::fromString($legacyOrder['id']),
            CustomerId::fromString($legacyOrder['customer_id']),
            new DateTimeImmutable($legacyOrder['created_at'])
        );
        
        // حدث تأكيد (إذا كان مؤكداً)
        if ($legacyOrder['status'] === 'confirmed') {
            $events[] = new OrderConfirmed(
                OrderId::fromString($legacyOrder['id']),
                new DateTimeImmutable($legacyOrder['confirmed_at'])
            );
        }
        
        // ... المزيد من الأحداث
        
        return $events;
    }
}
```

**المخاطر:**
- خطر عالٍ
- downtime طويل
- صعوبة التراجع

#### 2. Strangler Fig Pattern (الأفضل)

**الفكرة:**
"خنق" النظام القديم تدريجياً.

**التنفيذ:**
```
المرحلة 1:
┌──────────────┐
│    Legacy    │
│    System    │
└──────────────┘

المرحلة 2:
┌────────────────────┐
│   New Feature X    │ ← Event Sourcing
└────────┬───────────┘
         │
┌────────▼───────────┐
│     Legacy         │
└────────────────────┘

المرحلة 3:
┌────────────────────┐
│   New Features     │
│  A, B, C           │
└────────┬───────────┘
         │
┌────────▼───────────┐
│     Legacy         │ (يتقلص)
└────────────────────┘

المرحلة 4:
┌────────────────────┐
│   New System       │ (كامل)
└────────────────────┘
```

**الكود:**
```php
class RoutingRepository implements OrderRepository {
    private OrderRepository $legacy;
    private OrderRepository $modern;
    private FeatureFlag $featureFlag;
    
    public function find(OrderId $id): ?Order {
        if ($this->featureFlag->isEnabled('modern-order-repository', $id->toString())) {
            return $this->modern->find($id);
        }
        return $this->legacy->find($id);
    }
    
    public function save(Order $order): void {
        // حفظ في النظامين (Dual Write)
        $this->legacy->save($order);
        
        if ($this->featureFlag->isEnabled('modern-order-repository')) {
            $this->modern->save($order);
        }
    }
}
```

#### 3. Event Interception

**الفكرة:**
التقاط التغييرات في النظام القديم وتحويلها لأحداث.

**التنفيذ:**
```php
// Interceptor في النظام القديم
class LegacyOrderInterceptor {
    private EventBus $eventBus;
    
    public function afterOrderSaved(array $orderData): void {
        // نشر حدث عندما يتم حفظ طلب
        $this->eventBus->publish(new OrderSavedInLegacySystem(
            orderId: $orderData['id'],
            data: $orderData
        ));
    }
}

// الاستماع في النظام الجديد
class LegacyOrderSyncListener {
    private OrderRepository $modernRepository;
    
    public function onOrderSavedInLegacySystem(OrderSavedInLegacySystem $event): void {
        // إعادة بناء الـ Order من بيانات Legacy
        $order = $this->convertToModernOrder($event->data());
        
        // حفظ في النظام الجديد
        $this->modernRepository->save($order);
    }
}
```

### Migration Plan Template

```markdown
# خطة Migration لـ [اسم النظام]

## الجدول الزمني

### الشهر 1: التحضير
- [ ] فهم شامل للنظام القديم
- [ ] رسم خريطة البيانات
- [ ] تحديد Bounded Contexts
- [ ] بناء Infrastructure جديد

### الشهر 2-3: Anti-Corruption Layer
- [ ] إنشاء Adapters
- [ ] بناء Event Store
- [ ] Dual Write للبيانات الجديدة
- [ ] Testing

### الشهر 4-6: Migration تدريجي
- [ ] Context by Context migration
- [ ] Feature Flags
- [ ] Monitoring
- [ ] Rollback plans

### الشهر 7-9: الاستقرار
- [ ] تحويل القراءات
- [ ] تحسين الأداء
- [ ] تدريب الفريق
- [ ] توثيق

### الشهر 10-12: التنظيف
- [ ] إيقاف النظام القديم
- [ ] حذف Legacy code
- [ ] Celebration! 🎉

## Risk Mitigation

### Risk 1: Data Loss
**Mitigation:** Dual write + Backup + Verification

### Risk 2: Performance Issues
**Mitigation:** Load testing + Caching + Optimization

### Risk 3: Team Resistance
**Mitigation:** Training + Pair programming + Quick wins

## Success Criteria
- [ ] 100% data migrated
- [ ] Performance equal or better
- [ ] Zero critical bugs
- [ ] Team comfortable
```

---

## 5.12 Monitoring & Observability

### Metrics للأنظمة الزمنية

**1. Event Store Metrics**
```yaml
metrics:
  event_store:
    - events_per_second
    - stream_count
    - average_events_per_stream
    - append_latency_p99
    - read_latency_p99
    - concurrency_conflicts_rate
```

**2. Projection Metrics**
```yaml
metrics:
  projections:
    - projection_lag_seconds  # الفرق بين آخر حدث وآخر projection
    - events_processed_per_second
    - failed_projections_count
    - retry_rate
```

**3. Saga Metrics**
```yaml
metrics:
  sagas:
    - active_sagas_count
    - saga_completion_time_p99
    - compensation_rate
    - stuck_sagas_count
```

### Dashboards

**Event Store Health:**
```
┌─────────────────────────────────────────────┐
│           Event Store Dashboard             │
├─────────────────────────────────────────────┤
│                                             │
│  Events/sec:      ████████  1,250/s         │
│  Streams:         ████████  50,000          │
│  Append Latency:  ████░░░░  12ms (p99)      │
│  Read Latency:    ███░░░░░  8ms (p99)       │
│                                             │
│  Projection Lag:  ██░░░░░░  2.5s            │
│  Failed Events:   ░░░░░░░░  0               │
│                                             │
│  [Graph: Events over time]                  │
│  [Graph: Latency trends]                    │
│                                             │
└─────────────────────────────────────────────┘
```

### Alerting

**Rules:**
```yaml
alerts:
  - name: High Projection Lag
    condition: projection_lag_seconds > 60
    severity: warning
    
  - name: Very High Projection Lag
    condition: projection_lag_seconds > 300
    severity: critical
    
  - name: Event Store Write Latency
    condition: append_latency_p99 > 100
    severity: warning
    
  - name: Stuck Saga
    condition: saga_stuck_duration > 3600
    severity: warning
    
  - name: Failed Projection
    condition: projection_failures_rate > 0.01
    severity: critical
```

### Distributed Tracing

```php
// Correlation ID في الأحداث
class DomainEvent {
    private EventId $id;
    private ?CorrelationId $correlationId;
    private ?CausationId $causationId;
    
    public function __construct() {
        $this->id = EventId::generate();
        $this->correlationId = Context::correlationId();
        $this->causationId = Context::currentEventId();
    }
}

// تتبع عبر الخدمات
class TracedEventBus implements EventBus {
    public function publish(DomainEvent $event): void {
        $span = $this->tracer->startSpan('publish_event', [
            'event_type' => get_class($event),
            'correlation_id' => $event->correlationId()?->toString(),
        ]);
        
        try {
            $this->inner->publish($event);
            $span->setStatus(StatusCode::OK);
        } catch (Exception $e) {
            $span->setStatus(StatusCode::ERROR, $e->getMessage());
            throw $e;
        } finally {
            $span->end();
        }
    }
}
```

---

## خاتمة الفصل الخامس - النسخة الموسعة

### ما تعلمناه في هذا الفصل الشامل

**الأساسيات:**
- الزمن كبعد رابع في الهندسة المعمارية
- الفرق بين النماذج الآنية والزمنية
- الـ Event كوحدة زمنية أساسية

**Event Sourcing العميق:**
- بناء Event Store من الصفر
- Optimistic Concurrency Control
- Snapshotting والـ Performance
- Async Processing والـ Scaling

**الأنماط الزمنية:**
- Temporal Database
- CQRS (Command Query Responsibility Segregation)
- Saga Pattern (Choreography & Orchestration)
- Process Manager
- Deadline Pattern

**Consistency:**
- Strong vs Eventual vs Causal
- 2PC, Saga, CRDTs
- Trade-offs واختيار الاستراتيجية

**التطبيق العملي:**
- دراسة حالة نظام مالي
- دراسة حالة E-commerce Platform كامل
- Order Fulfillment Process
- Inventory Management

**Migration:**
- Big Bang vs Strangler Fig
- Event Interception
- خطة Migration كاملة

**Observability:**
- Metrics للأنظمة الزمنية
- Dashboards والـ Alerting
- Distributed Tracing

### الخلاصة

> "الأنظمة الزمنية ليست مجرد تقنية، بل طريقة تفكير. عندما تتبنى هذا الفكر، تتحول من "مدير بيانات" إلى "حافظ للتاريخ"، ومن "مطور" إلى "معماري زمني."

### إحصائيات الفصل

| المقياس | القيمة |
|---------|--------|
| **الأقسام** | 12 قسم |
| **الكلمات** | 12,000+ كلمة |
| **الصفحات** | **40+ صفحة** ✅ |
| **الأمثلة البرمجية** | 30+ مثال |
| **دراسات الحالة** | 3 دراسات |

---

**© 2025 محمد العبيد | المعماري**

*"السيادة الحقيقية على حرفتك"*

**نهاية الفصل الخامس - السيادة الزمنية**
**الإصدار الكامل والموسع - 40+ صفحة** ✅

---

**الفصول المكتملة:**
- ✅ الفصل الأول: المانيفستو التأسيسي (30 صفحة)
- ✅ الفصل الثاني: أنطولوجيا التفكيك (40 صفحة)
- ✅ الفصل الثالث: سيكولوجية المعماري (40 صفحة)
- ✅ الفصل الرابع: فن التجريد (20 صفحة)
- ✅ الفصل الخامس: السيادة الزمنية (40 صفحة)

**المجموع: 170 صفحة!** 🎉🎉🎉



## 5.13 Advanced Patterns

### Event Versioning & Evolution

**Problem:**
Events change over time. How do we maintain backward compatibility?

**Solutions:**

#### 1. Upcasting
```php
// Version 1
class OrderCreatedV1 {
    public function __construct(
        public readonly string $orderId,
        public readonly string $customerId,
        public readonly float $total  // Just a float
    ) {}
}

// Version 2
class OrderCreatedV2 {
    public function __construct(
        public readonly string $orderId,
        public readonly string $customerId,
        public readonly Money $total,  // Now a Money object
        public readonly Currency $currency  // New field
    ) {}
}

// Upcaster
class OrderCreatedUpcaster implements EventUpcaster {
    public function upcast(array $eventData, int $version): array {
        if ($version === 1) {
            // Upgrade V1 to V2
            $eventData['total'] = [
                'amount' => $eventData['total'],
                'currency' => 'USD'  // Default for old events
            ];
            $eventData['version'] = 2;
        }
        
        return $eventData;
    }
}

// Usage in Event Store
class VersionedEventStore {
    private array $upcasters = [];
    
    public function registerUpcaster(string $eventType, EventUpcaster $upcaster): void {
        $this->upcasters[$eventType] = $upcaster;
    }
    
    public function readStream(string $streamId): EventStream {
        $rows = $this->db->fetchAll(/* ... */);
        
        $events = array_map(function($row) {
            $data = json_decode($row['payload'], true);
            
            // Apply upcasters if needed
            if (isset($this->upcasters[$row['event_type']])) {
                $data = $this->upcasters[$row['event_type']]->upcast(
                    $data, 
                    $row['version'] ?? 1
                );
            }
            
            return $this->serializer->deserialize($row['event_type'], $data);
        }, $rows);
        
        return new EventStream($events);
    }
}
```

#### 2. Event Transformation
```php
// When a significant change happens, transform old events
class EventTransformer {
    public function transformOldEvents(string $streamId): void {
        $oldEvents = $this->eventStore->readStream($streamId);
        
        $newEvents = [];
        foreach ($oldEvents as $event) {
            $newEvents[] = $this->transformEvent($event);
        }
        
        // Store in new stream
        $this->eventStore->append("{$streamId}:v2", 0, $newEvents);
    }
    
    private function transformEvent(DomainEvent $event): DomainEvent {
        return match (get_class($event)) {
            OldOrderCreated::class => new NewOrderCreated(
                orderId: $event->orderId(),
                customerId: $event->customerId(),
                // Transform old fields to new format
            ),
            default => $event
        };
    }
}
```

### Multi-Tenancy in Event Sourcing

```php
// Tenant-aware Event Store
class MultiTenantEventStore implements EventStore {
    public function append(
        string $streamId,
        int $expectedVersion,
        array $events,
        TenantId $tenantId
    ): void {
        // Prefix stream ID with tenant
        $tenantStreamId = "{$tenantId->toString()}:{$streamId}";
        
        // Add tenant metadata to each event
        foreach ($events as $event) {
            $event->withMetadata(['tenant_id' => $tenantId->toString()]);
        }
        
        $this->inner->append($tenantStreamId, $expectedVersion, $events);
    }
    
    public function readStream(string $streamId, TenantId $tenantId): EventStream {
        $tenantStreamId = "{$tenantId->toString()}:{$streamId}";
        return $this->inner->readStream($tenantStreamId);
    }
}

// Tenant isolation in queries
class TenantAwareProjection {
    private Connection $db;
    private TenantContext $tenantContext;
    
    public function getOrders(): array {
        return $this->db->fetchAll(
            'SELECT * FROM orders WHERE tenant_id = ?',
            [$this->tenantContext->currentTenantId()->toString()]
        );
    }
}
```

### GDPR & Data Privacy

**Right to be Forgotten:**
```php
class GDPRCompliance {
    public function anonymizeCustomerData(CustomerId $customerId): void {
        // 1. Read all events for customer
        $events = $this->eventStore->readAllStreamsForCustomer($customerId);
        
        // 2. Create anonymized versions
        $anonymizedEvents = [];
        foreach ($events as $event) {
            $anonymizedEvents[] = $this->anonymizeEvent($event);
        }
        
        // 3. Replace in event store (with audit trail)
        $this->eventStore->replaceStream(
            "customer:{$customerId->toString()}",
            $anonymizedEvents
        );
        
        // 4. Delete projections
        $this->projections->deleteAllForCustomer($customerId);
    }
    
    private function anonymizeEvent(DomainEvent $event): DomainEvent {
        return match (get_class($event)) {
            CustomerRegistered::class => new CustomerRegistered(
                customerId: $event->customerId(),
                email: 'anonymized@example.com',
                name: 'Anonymous User',
                // Keep other non-PII data
            ),
            default => $event
        };
    }
}
```

---

## 5.14 Benchmarks & Performance Comparison

### Event Sourcing vs CRUD Performance

| Operation | CRUD | Event Sourcing | Notes |
|-----------|------|----------------|-------|
| **Simple Write** | 5ms | 8ms | +60% overhead |
| **Simple Read** | 3ms | 3ms | Same (projection) |
| **Complex Read** | 50ms | 5ms | Projection pre-computed |
| **Audit Query** | N/A | 20ms | Not possible in CRUD |
| **Replay 1000 events** | N/A | 200ms | For recovery |

### Scaling Strategies

**Horizontal Scaling:**
```
┌─────────────────────────────────────────────────────────────┐
│                      Load Balancer                           │
└──────────────┬──────────────────────────────────────────────┘
               │
    ┌──────────┼──────────┬──────────┐
    │          │          │          │
┌───▼───┐ ┌────▼────┐ ┌───▼───┐ ┌───▼───┐
│App 1  │ │ App 2   │ │App 3  │ │App 4  │
└───┬───┘ └────┬────┘ └───┬───┘ └───┬───┘
    │          │          │          │
    └──────────┴──────────┴──────────┘
               │
        ┌──────▼──────┐
        │  Event Bus  │
        │   (Kafka)   │
        └──────┬──────┘
               │
        ┌──────▼──────┐
        │ Event Store │
        │  (Cluster)  │
        └─────────────┘
```

**Sharding Strategy:**
```php
// Sharding by Aggregate ID
class ShardedEventStore implements EventStore {
    private array $shards;
    
    public function append(string $streamId, int $expectedVersion, array $events): void {
        $shard = $this->getShardFor($streamId);
        $shard->append($streamId, $expectedVersion, $events);
    }
    
    private function getShardFor(string $streamId): EventStore {
        $hash = crc32($streamId);
        $shardIndex = $hash % count($this->shards);
        return $this->shards[$shardIndex];
    }
}
```

---

**© 2025 محمد العبيد | المعماري**

*"السيادة الحقيقية على حرفتك"*

**نهاية الفصل الخامس - الإصدار النهائي**

